#!/usr/bin/perl -w

# XXX this may need changing for the new file name schemes

use strict;
use DBI;
use Cwd 'abs_path';
use File::Temp 'tempdir';
use File::Path 'remove_tree';

@ARGV >= 2 or die "Usage: $0 DATABASE SOURCE_FILE [SOURCE_FILE]...\n";
my $database = shift @ARGV;
my $dbh = DBI->connect("dbi:SQLite:dbname=$database", '', '',
		       { RaiseError => 1, AutoCommit => 0 });

run_sql(<<EOF, 1);
CREATE TABLE IF NOT EXISTS run_data (
    run_id INT PRIMARY KEY,
    topology VARCHAR(255),
    boot_time INT,
    host VARCHAR(255),
    experiment VARCHAR(255),
    schedule VARCHAR(255),
    datasize INT,
    end_run INT
);
EOF

run_sql(<<EOF, 1);
CREATE INDEX IF NOT EXISTS run_data_idx
ON run_data(topology, boot_time, experiment, schedule, datasize, end_run, host);
EOF

run_sql(<<EOF, 1);
CREATE INDEX IF NOT EXISTS run_data_idx2
ON run_data(experiment, datasize, schedule, end_run, host);
EOF

run_sql(<<EOF, 1);
CREATE TABLE IF NOT EXISTS lwmon_data (
    run_id INT,
    timestamp INT,
    name VARCHAR(255),
    parm VARCHAR(255),
    key VARCHAR(255),
    value INT
);
EOF

run_sql(<<EOF, 1);
CREATE INDEX IF NOT EXISTS lwmon_data_idx
ON lwmon_data(run_id, name, parm, key);
EOF

my $has_file = $dbh->prepare(<<EOF);
SELECT run_id
FROM run_data
WHERE topology = ?
  AND boot_time = ?
  AND experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND end_run = ?;
EOF

my $has_run = $dbh->prepare(<<EOF);
SELECT run_id
FROM run_data
WHERE topology = ?
  AND boot_time = ?
  AND experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND end_run = ?
  AND host = ?;
EOF

my $last_run = $dbh->prepare('SELECT MAX(run_id) FROM run_data;');

my $new_run = $dbh->prepare(<<EOF);
INSERT INTO run_data
(run_id, topology, boot_time, experiment, schedule, datasize, end_run, host)
VALUES (?, ?, ?, ?, ?, ?, ?, ?);
EOF

my $tmpdir = tempdir(CLEANUP => 1) or die "tempdir: $!\n";

my ($last_id) = map { $_->[0] } @{ $dbh->selectall_arrayref($last_run, {}) };
$last_id ||= 0;
for (my $n_file = 0; $n_file < @ARGV; $n_file++) {
    my $name = $ARGV[$n_file];
    my $path = abs_path($name);
    defined $path or die "Something wrong with $name\n";
    # XXX the next line needs to be changed for the new file names
    $path =~ m|/([^:]+):(\d+)-(\w+)-(\w+)-(\d+)-(\d+)\.|
	or die "Invalid datafile name: $name\n";
    my ($topology, $boot_time, $experiment, $schedule, $size, $endrun) =
	($1, $2, $3, $4, $5, $6);
    my @data = ($topology, $boot_time, $experiment, $schedule, $size, $endrun);
    my ($has_id) = map { $_->[0] } @{ $dbh->selectall_arrayref($has_file, {}, @data) };
    if (defined $has_id) {
	#print "Skipping $name: already in database\n";
	next;
    }
    print "Reading $name (", ($n_file + 1), "/", scalar(@ARGV), ")\n";
    system('tar', 'xf', $path, '-C', $tmpdir);
    opendir(TMPDIR, $tmpdir) or die "$tmpdir: $!\n";
    while (defined (my $fn = readdir TMPDIR)) {
	$fn =~ /^\./ and next;
	$fn =~ /^(\w+)\./ or die "Invalid file in $name: $fn\n";
	my $host = $1;
	$last_id++;
	$new_run->execute($last_id, @data, $host);
	print "    $last_id: $fn\n";
	my $count = 0;
	open(SQL, '-|', 'lwmon-to-sql',
			'-tlwmon_data',
			"-erun_id=$last_id",
			'-stimestamp',
			'-nname',
			'-pparm',
			'-kkey',
			'-dvalue',
			"$tmpdir/$fn") or die "lwmon-to-sql: $!\n";
	while (<SQL>) {
	    chomp;
	    run_sql($_, 0);
	    $count++;
	    $count < 10000 and next;
	    $count = 0;
	    run_sql(undef, 1);
	}
	if (close SQL) {
	    run_sql(undef, 1);
	    next;
	}
	$? == -1 and die "lwmon-to-sql: $!\n";
	$? & 0x7f and die 'lwmon-to-sql killed by signal ' . ($? & 0x7f) . "\n";
	die 'lwmon-to-sql exited with status ' . ($? >> 8) . "\n";
    }
    closedir TMPDIR;
    remove_tree($tmpdir);
    mkdir($tmpdir) or die "$tmpdir: $!\n";
}

$dbh->disconnect();

sub run_sql {
    my ($query, $commit) = @_;
    defined $query and $dbh->do($query) || die "$query\n" . $dbh->errstr . "\n";
    $commit and $dbh->commit || die "Commit: " . $dbh->errstr . "\n";
}

