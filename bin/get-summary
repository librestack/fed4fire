#!/usr/bin/perl -w

use strict;
use DBI;
use POSIX 'strftime';

@ARGV > 1 or die "Usage: $0 DATABASE TYPE... DATA...\n";
my $database = shift @ARGV;
my $dbh = DBI->connect("dbi:SQLite:dbname=$database", '', '',
		       { RaiseError => 1, ReadOnly => 1 });

my (%type, %experiment, %schedule, %data, @data, $all_data,
    %topology, $all_topologies, $instance, %sizes, @group, %gptr, $output);
while (@ARGV) {
    my $cmd = shift @ARGV;
    if ($cmd =~ /^out(?:put)?=(.*)$/i) {
	$output = $1;
	next;
    }
    if ($cmd =~ /^(?:client|router|server)$/i) {
	$type{lc $cmd} = 1;
	next;
    }
    if (lc($cmd) eq 'all_types' || lc($cmd) eq 'at') {
	$type{$_} = 1 for qw(client router server udp);
	next;
    }
    if ($cmd =~ /^(?:multicast|scp|tcp|udp)$/i) {
	$experiment{lc $cmd} = 1;
	next;
    }
    if (lc($cmd) eq 'all_experiments' || lc($cmd) eq 'ae') {
	$experiment{$_} = 1 for qw(multicast scp tcp udp);
	next;
    }
    if ($cmd =~ /^(?:immediate|random)$/i) {
	$schedule{lc $cmd} = 1;
	next;
    }
    if (lc($cmd) eq 'all_schedules' || lc($cmd) eq 'as') {
	$schedule{$_} = 1 for qw(immediate random);
	next;
    }
    if ($cmd =~ /^S\d+(?:R\d+)?L\d+$/) {
	$topology{$cmd} = 1;
	next;
    }
    if (lc($cmd) eq 'all_topologies' || lc($cmd) eq 'an') {
	$all_topologies = 1;
	next;
    }
    if (lc($cmd) eq 'instance' || lc($cmd) eq 'inst') {
	$instance = 1;
	next;
    }
    if ($cmd =~ /^\d+$/) {
	$sizes{$cmd} = 1;
	next;
    }
    if (lc($cmd) eq 'all_sizes' || lc($cmd) eq 'az') {
	$sizes{$_} = 1 for (32, 128, 512, 2048);
	next;
    }
    if ($cmd =~ /^group=(\d+(?:,\d+)*)$/ ) {
	@group = map { $_ - 1 } split(/,/, $1);
	%gptr = map { ($_ => 0) } @group;
	next;
    }
    if (lc($cmd) eq 'all_data' || lc($cmd) eq 'ad') {
	$all_data = 1;
	next;
    }
    $cmd = lc $cmd;
    exists $data{$cmd} and next;
    $data{lc $cmd} = 1;
    push @data, $cmd;
}
keys %type or die "No host types requested\n";
keys %experiment or die "No experiment types selected\n";
keys %schedule or die "No schedules selected\n";
keys %sizes or die "No sizes selected\n";

$all_data || @data or die "No data requested\n";

my %fmt = (
    mem         => '%.2f',
    swap        => '%.2f',

    rx          => '%.2f',
    rx2         => '%.2f',
    tx          => '%.2f',
    tx2         => '%.2f',
    net         => '%.2f',
    net2        => '%.2f',

    load        => '%.3f',
    syscpu      => '%.3f',
    totcpu      => '%.3f',
    usercpu     => '%.3f',

    duration    => '%.3f',
    update_time => '%.3f',

    (map { ("if$_.sent" => '%.2f', "if$_.received" => '%.2f') } (1, 2, 3)),
);

my %scale = (); # map { ("if$_.sent" => 1e-6, "if$_.received" => 1e-6) } (1, 2, 3);

my %unit = (
    mem         => 'MB',
    swap        => 'MB',

    rx          => 'MB/s',
    rx2         => 'MB/s',
    tx          => 'MB/s',
    tx2         => 'MB/s',
    net         => 'MB/s',
    net2        => 'MB/s',

    update_time => 'sec',

    (map { ("if$_.sent" => 'MB', "if$_.received" => 'MB') } (1, 2, 3)),
);

my %group;

if ($all_topologies || $instance) {
    for my $tp (@{ $dbh->selectall_arrayref('SELECT topology FROM lwmon_summary GROUP BY topology;') }) {
	$topology{$tp->[0]} = 1;
    }
}
if (keys %topology) {
    if ($instance) {
	(grep { $_ < 0 || $_ > 5 } @group)
	    and die "Invalid group @{[map { $_+1 } @group]}\n";
	my $ilist = $dbh->prepare(<<EOF);
SELECT instance
FROM lwmon_summary
WHERE topology = ?
GROUP BY instance
EOF
	my $rdata = $dbh->prepare(<<EOF);
SELECT n_clients, count, total, square
FROM lwmon_summary
WHERE experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND host_type = ?
  AND topology = ?
  AND instance = ?
  AND key = ?
ORDER BY n_clients
EOF
	my $rkeys = $dbh->prepare(<<EOF);
SELECT key
FROM lwmon_summary
WHERE experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND host_type = ?
  AND topology = ?
  AND instance = ?
GROUP BY key
EOF
	for my $topology (sort keys %topology) {
	    for my $ip (@{ $dbh->selectall_arrayref($ilist, {}, $topology) }) {
		my $instance = $ip->[0];
		for my $experiment (sort keys %experiment) {
		    for my $schedule (sort keys %schedule) {
			for my $size (sort keys %sizes) {
			    for my $type (sort keys %type) {
				show_data($rdata, $rkeys,
					  $experiment, $schedule, $size, $type,
					  $topology, $instance);
			    }
			}
		    }
		}
	    }
	}
    } else {
	(grep { $_ < 0 || $_ > 4 } @group)
	    and die "Invalid group @{[map { $_+1 } @group]}\n";
	my $rdata = $dbh->prepare(<<EOF);
SELECT n_clients, count, total, square
FROM lwmon_summary
WHERE experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND host_type = ?
  AND topology = ?
  AND key = ?
ORDER BY n_clients
EOF
	my $rkeys = $dbh->prepare(<<EOF);
SELECT key
FROM lwmon_summary
WHERE experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND host_type = ?
  AND topology = ?
GROUP BY key
EOF
	for my $topology (sort keys %topology) {
	    for my $experiment (sort keys %experiment) {
		for my $schedule (sort keys %schedule) {
		    for my $size (sort keys %sizes) {
			for my $type (sort keys %type) {
			    show_data($rdata, $rkeys,
				      $experiment, $schedule, $size, $type, $topology);
			}
		    }
		}
	    }
	}
    }
} else {
    (grep { $_ < 0 || $_ > 3 } @group) and die "Invalid group @{[map { $_+1 } @group]}\n";
    my $rdata = $dbh->prepare(<<EOF);
SELECT n_clients, SUM(count), SUM(total), SUM(square)
FROM lwmon_summary
WHERE experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND host_type = ?
  AND key = ?
GROUP BY n_clients
ORDER BY n_clients
EOF
    my $rkeys = $dbh->prepare(<<EOF);
SELECT key
FROM lwmon_summary
WHERE experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND host_type = ?
GROUP BY key
EOF
    for my $experiment (sort keys %experiment) {
	for my $schedule (sort keys %schedule) {
	    for my $size (sort keys %sizes) {
		for my $type (sort keys %type) {
		    show_data($rdata, $rkeys, $experiment, $schedule, $size, $type);
		}
	    }
	}
    }
}

$dbh->disconnect();

for my $gn (sort keys %group) {
    my $dest;
    if (defined $output) {
	print "$gn\n";
	($dest = $gn) =~ s/\s+/./g;
	$dest = sprintf $output, $dest;
	open(OFILE, '>', $dest) or die "$dest: $!\n";
	select OFILE;
    }
    print "$gn:\n";
    my $title1 = '';
    my $title2 = '';
    my @rows;
    for my $gp (@{$group{$gn}}) {
	my ($glen, $grest, $title, $max_clients, $gdata) = @$gp;
	$title1 .= '  ' . adjust($grest, $glen);
	$title2 .= '  ' . adjust($title, $glen);
	for (my $i = 0; $i <= $max_clients; $i++) {
	    my $n = $gdata->[$i];
	    defined $n or $n = ' ' x $glen;
	    defined $rows[$i] or $rows[$i] = '';
	    $rows[$i] .= '  ' . $n;
	}
    }
    print "#clients$title1\n        $title2\n";
    for (my $i = 0; $i < @rows; $i++) {
	defined $rows[$i] && $rows[$i] =~ /\S/ or next;
	printf "%8d%s\n", $i, $rows[$i];
    }
    print "\n";
    if (defined $output) {
	select STDOUT;
	close OFILE or die "$dest: $!\n";
    }
}

sub adjust {
    my ($s, $clen) = @_;
    length($s) < $clen or return $s;
    my $l2 = $clen - length($s);
    my $l1 = int($l2 / 2);
    $l2 -= $l1;
    return (' ' x $l1) . $s . (' ' x $l2);
}

sub show_data {
    my ($rdata, $rkeys, @parms) = @_;
    my $title1 = join(' ', @parms);
    my $title2 = '';
    my @values;
    my @space;
    my $max_clients = -1;
    my @sdata = @data;
    my %sdata = %data;
    if ($all_data) {
	for my $dp (@{ $dbh->selectall_arrayref($rkeys, {}, @parms) }) {
	    my $cmd = lc $dp->[0];
	    exists $sdata{$cmd} and next;
	    $sdata{lc $cmd} = 1;
	    push @sdata, $cmd;
	}
    }
    my $glen = 0;
    for my $data (@sdata) {
	my $prndata = $data;
	exists $unit{$data} and $prndata .= "($unit{$data})";
	$prndata .= ' (num,  std)';
	my $len = length $prndata;
	my @column;
	for my $dp (@{ $dbh->selectall_arrayref($rdata, {}, @parms, $data) }) {
	    my ($nc, $count, $total, $square) = @$dp;
	    defined $count && $count > 0 or next;
	    my $avg = $total / $count;
	    my $std = ')      ';
	    if ($count > 1) {
		my $var = ($square - 2 * $avg * $total + $avg * $avg * $count)
			/ ($count - 1);
		# avoid square root of "-0"
		$var < 0 && $var > -1e-10 and $var = 0;
		$std = sqrt($var),
		exists $scale{$data} and $std *= $scale{$data};
		$std = sprintf ",%5.1f)", $std;
	    }
	    $max_clients < $nc and $max_clients = $nc;
	    exists $scale{$data} and $avg *= $scale{$data};
	    exists $fmt{$data} and $avg = sprintf $fmt{$data}, $avg;
	    my $disp = sprintf "%s %5s%s", $avg, "($count", $std;
	    $len < length $disp and $len = length $disp;
	    $column[$nc] = $disp;
	}
	push @values, \@column;
	$len += 2;
	push @space, $len;
	$glen += $len;
	$title2 .= sprintf "%${len}s", $prndata;
    }
    $max_clients >= 0 or return;
    my ($gindex, $grest, @gdata, $dest);
    if (@group) {
	$gindex = join(' ', @parms[@group]);
	$grest = join(' ', map { $parms[$_] } grep { ! exists $gptr{$_} } (0..$#parms));
	$glen < length $grest and $glen = length $grest;
	$glen < length $title2 and $glen = length $title2;
    } else {
	if (defined $output) {
	    $dest = sprintf $output, join('.', @parms);
	    open(OFILE, '>', $dest) or die "$dest: $!\n";
	    select OFILE;
	}
	print $title1, "\n#clients", $title2, "\n";
    }
    for (my $i = 0; $i <= $max_clients; $i++) {
	my $row = '';
	my $has_data = 0;
	for (my $j = 0; $j < @space; $j++) {
	    if (defined $values[$j][$i]) {
		$has_data = 1;
		$row .= sprintf "%$space[$j]s", $values[$j][$i];
	    } else {
		$row .= ' ' x $space[$j];
	    }
	}
	$has_data or next;
	if (@group) {
	    $gdata[$i] = $row;
	} else {
	    printf "%8d%s\n", $i, $row;
	}
    }
    if (@group) {
	push @{$group{$gindex}}, [$glen, $grest, $title2, $max_clients, \@gdata];
    } else {
	print "\n";
	if (defined $output) {
	    select STDOUT;
	    close OFILE or die "$dest: $!\n";
	}
    }
}

