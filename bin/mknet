#!/usr/bin/perl -w

use strict;
use POSIX 'strftime';
use FindBin '$Bin';

$| = 1;

my $pr4 = '192.168';
my $pr6 = '2a03:4980:123';
my $base6 = 0x9a00;

my ($R, $L, $RSPEC, $YAML, $SCRIPT, $PWD, %K, $EXP);
my $S = 1;
my $TIME = 120;
my $DIR = '/tmp';
-f "$Bin/../objects/id_rsa.pub" and unshift @ARGV, "K=$Bin/../objects/id_rsa.pub";
while (@ARGV) {
    my $A = shift @ARGV;
    $A =~ /^S=(\d+)$/i and $S = $1, next;
    $A =~ /^R=(\d+)$/i and $R = $1, next;
    $A =~ /^L=(\d+)$/i and $L = $1, next;
    $A =~ /^TIME=(\d+)$/i and $TIME = $1, next;
    $A =~ /^RSPEC=(.+)$/i and $RSPEC = $1, next;
    $A =~ /^YAML=(.+)$/i and $YAML = $1, next;
    $A =~ /^SCRIPT=(.+)$/i and $SCRIPT = $1, next;
    $A =~ /^PWD=(.+)$/i and $PWD = $1, next;
    $A =~ /^EXP=(.+)$/i and $EXP = $1, next;
    $A =~ /^DIR=(.+)$/i and $DIR = $1, next;
    $A =~ /^K(\w*)=(.*)$/ or die "Unknown option $A\n";
    my ($user, $key) = ($1, $2);
    open(KF, '<', $key) or die "K=$key: $!\n";
    my $K = <KF>;
    close KF;
    defined $K or die "$A: empty key\n";
    chomp $K;
    push @{$K{$user}}, $K;
}
defined $L or die "Missing clients per LAN, L\n";
$S < 1 and die "S must be at least 1\n";
$L < 1 and die "L must be at least 1\n";
defined $R && $R < 1 and die "R must be at least 1\n";

if (! defined $EXP) {
    $EXP = "S$S";
    defined $R and $EXP .= "R$R";
    $EXP .= "L$L";
}

-d "$DIR/$EXP" or mkdir "$DIR/$EXP" || die "$DIR/$EXP: $!\n";
defined $RSPEC or $RSPEC = "$DIR/$EXP/action.rspec";
defined $YAML or $YAML = "$DIR/$EXP/action.yaml";
defined $SCRIPT or $SCRIPT = "$DIR/$EXP/action.script";

my $nLAN = defined $R ? (2 ** ($R - 1)) : 1;
my $rLAN = (defined $R && $R > 1) ? (2 ** ($R - 1) - 1) : 0;
my $C = $nLAN * $L;
# In theory we would be checking for overflow on $C aka "experiment so
# large you won't find enough hardware".

printf "Servers (S):        %8d\n", $S;
defined $R and printf "Router path (R):    %8d\n", $R;
defined $R and printf "Router LANs:        %8d\n", $rLAN;
printf "Client LANs:        %8d\n", $nLAN;
printf "Clente per LAN (L): %8d\n", $L;
printf "Total clients (C):  %8d\n", $C;
print "\n";

my ($rspec, $yaml, $script, @nodes, @routes);
create_rspec();
if (defined $RSPEC) {
    print "Creating rspec ($RSPEC)... ";
    open(RSPEC, '>', $RSPEC) or die "$RSPEC: $!\n";
    print RSPEC $rspec or die "$RSPEC: $!\n";
    close RSPEC or die "$RSPEC: $!\n";
    print "OK\n";
}
if (defined $YAML) {
    print "Creating yaml ($YAML)... ";
    create_yaml();
    open(YAML, '>', $YAML) or die "$YAML: $!\n";
    print YAML $yaml or die "$YAML: $!\n";
    close YAML or die "$YAML: $!\n";
    print "OK\n";
}
if (defined $SCRIPT) {
    print "Creating script ($SCRIPT)... ";
    create_script();
    open(SCRIPT, '>', $SCRIPT) or die "$SCRIPT: $!\n";
    print SCRIPT $script or die "$SCRIPT: $!\n";
    close SCRIPT or die "$SCRIPT: $!\n";
    print "OK\n";
}
exit 0;

sub create_rspec {
    # used in making up graph coordinates
    my $dx = 1024 / ($C + 1);
    my $dy = 512 / (($R || 0) + 3);
    # OK, make up the rspec
    (my $now = strftime '%Y-%m-%dT%H:%M:%S.000%z', gmtime) =~ s/(\d{2})$/:$1/;
    $rspec = <<"EOF";
<?xml version="1.0" encoding="UTF-8"?>
<rspec
  xmlns="http://www.geni.net/resources/rspec/3"
  type="request"
  generated="$now"
  xmlns:emulab="http://www.protogeni.net/resources/rspec/ext/emulab/1"
  xmlns:delay="http://www.protogeni.net/resources/rspec/ext/delay/1"
  xmlns:jfed-command="http://jfed.iminds.be/rspec/ext/jfed-command/1"
  xmlns:client="http://www.protogeni.net/resources/rspec/ext/client/1"
  xmlns:jfed-ssh-keys="http://jfed.iminds.be/rspec/ext/jfed-ssh-keys/1"
  xmlns:jfed="http://jfed.iminds.be/rspec/ext/jfed/1"
  xmlns:sharedvlan="http://www.protogeni.net/resources/rspec/ext/shared-vlan/1"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.geni.net/resources/rspec/3 http://www.geni.net/resources/rspec/3/manifest.xsd "
  >
EOF
    my $ipstart = 8;
    my $netstart = 0;
    my $clientlan = $netstart;
    my $routerlan = $clientlan + $nLAN;
    my $serverlan = defined $R ? ($routerlan + $rLAN) : $clientlan;
    my $serverip = $ipstart;
    my $routerip = 4;
    my $linkno = 0;
    my $posx = $dx;
    my $posy = 512;
    my @routers = ();
    my $routerno = 0;

    # add all clients and bottom level routers and link them together
    # we link using the second interface, as the first interface is the
    # control interface where we aren't supposed to have experiment traffic
    my @clients = ();
    my $clientno = 0;
    for (my $ln = 0; $ln < $nLAN; $ln++) {
	my $rx = 0;
	my $clientip = $ipstart;
	for (my $cn = 0; $cn < $L; $cn++) {
	    # add client
	    $rspec .= <<"EOF";
  <node client_id="client$clientno" exclusive="true" component_manager_id="urn:publicid:IDN+wall2.ilabt.iminds.be+authority+cm">
    <sliver_type name="raw-pc">
      <disk_image name="urn:publicid:IDN+wall2.ilabt.iminds.be+image+emulab-ops:UBUNTU20-64-STD"/>
    </sliver_type>
    <jfed:ansible_group name="client"/>
    <location xmlns="http://jfed.iminds.be/rspec/ext/jfed/1" x="$posx" y="$posy"/>
    <interface client_id="client$clientno:if0">
      <ip address="10.0.$clientlan.$clientip" netmask="255.255.255.0" type="ipv4"/>
    </interface>
    <interface client_id="client$clientno:if1">
      <ip address="$pr4.$clientlan.$clientip" netmask="255.255.255.0" type="ipv4"/>
    </interface>
  </node>
EOF
	    push @nodes, [ 'client', $clientno, $clientlan, $clientip ];
	    push @clients, "client$clientno";
	    $clientno++;
	    $rx += $posx;
	    $posx += $dx;
	    $clientip++;
	    defined $R or $serverip++;
	}
	defined $R or next;
	$rx /= $L;
	# add router
	push @nodes, [ 'router',$routerno, $clientlan, 1, $routerlan, $routerip ];
	push @routes, [ $clientlan, $routerlan, $routerip ],
		      [ $routerlan, $clientlan, 1 ];
	my $py = $posy - $dy;
	push @routers, [$routerno, $rx, $py, $routerlan];
	$rspec .= <<"EOF";
  <node client_id="router$routerno" exclusive="true" component_manager_id="urn:publicid:IDN+wall2.ilabt.iminds.be+authority+cm">
    <sliver_type name="raw-pc">
      <disk_image name="urn:publicid:IDN+wall2.ilabt.iminds.be+image+emulab-ops:UBUNTU20-64-STD"/>
    </sliver_type>
    <location xmlns="http://jfed.iminds.be/rspec/ext/jfed/1" x="$rx" y="$py"/>
    <interface client_id="router$routerno:if0">
      <ip address="10.0.$clientlan.1" netmask="255.255.255.0" type="ipv4"/>
    </interface>
    <interface client_id="router$routerno:if1">
      <ip address="$pr4.$clientlan.1" netmask="255.255.255.0" type="ipv4"/>
    </interface>
    <interface client_id="router$routerno:if2">
      <ip address="$pr4.$routerlan.$routerip" netmask="255.255.255.0" type="ipv4"/>
    </interface>
  </node>
EOF
	# add links client <-> router
	$rspec .= <<"EOF";
  <link client_id="link$linkno">
    <component_manager name="urn:publicid:IDN+wall2.ilabt.iminds.be+authority+cm"/>
EOF
	for my $c (@clients) {
	    $rspec .= <<"EOF";
    <interface_ref client_id="$c:if1"/>
EOF
	}
	$rspec .= <<"EOF";
    <interface_ref client_id="router$routerno:if1"/>
    <link_type name="lan"/>
  </link>
EOF
	$routerno++;
	@clients = ();
	$linkno++;
	$clientlan++;
	$routerip++;
	$routerip < 6 and next;
	$routerip = 4;
	$routerlan++;
    }

    if (defined $R) {
	# now add routers until there's just one left, where we'll attach the servers
	while (@routers > 1) {
	    my @or = @routers;
	    @routers = ();
	    while (@or) {
		# join two routers with a router bwteen them
		my ($r1, $x1, $y1, $l1) = @{shift @or};
		my ($r2, $x2, $y2, $l2) = @{shift @or};
		$l1 == $l2 or die "Internal error on router LAN: $l1 != $l2\n";
		my $rx = ($x1 + $x2) / 2;
		my $ry = $y1 - $dx;
		my $v6lan = sprintf "%02x", $l1 - $netstart;
		push @nodes, [ 'router', $routerno, $l1, 1, $routerlan, $routerip ];
		push @routes, [ $l1, $routerlan, $routerip ],
			      [ $routerlan, $l1, 1 ];
		push @routers, [$routerno, $rx, $ry, $routerlan];
		$rspec .= <<"EOF";
  <node client_id="router$routerno" exclusive="true" component_manager_id="urn:publicid:IDN+wall2.ilabt.iminds.be+authority+cm">
    <sliver_type name="raw-pc">
      <disk_image name="urn:publicid:IDN+wall2.ilabt.iminds.be+image+emulab-ops:UBUNTU20-64-STD"/>
    </sliver_type>
    <location xmlns="http://jfed.iminds.be/rspec/ext/jfed/1" x="$rx" y="$ry"/>
    <interface client_id="router$routerno:if0">
      <ip address="10.0.$l1.1" netmask="255.255.255.0" type="ipv4"/>
    </interface>
    <interface client_id="router$routerno:if1">
      <ip address="$pr4.$l1.1" netmask="255.255.255.0" type="ipv4"/>
    </interface>
    <interface client_id="router$routerno:if2">
      <ip address="$pr4.$routerlan.$routerip" netmask="255.255.255.0" type="ipv4"/>
    </interface>
  </node>
  <link client_id="link$linkno">
    <component_manager name="urn:publicid:IDN+wall2.ilabt.iminds.be+authority+cm"/>
    <interface_ref client_id="router$r1:if2"/>
    <interface_ref client_id="router$r2:if2"/>
    <interface_ref client_id="router$routerno:if1"/>
    <link_type name="lan"/>
  </link>
EOF
		$linkno++;
		$routerno++;
		$routerip++;
		$routerip < 6 and next;
		$routerip = 4;
		$routerlan++;
	    }
	}
    }

    # add the servers
    my ($top_router, $top_x, $top_y, $_serverlan) =
	defined $R ? @{shift @routers} : (undef, 512, 256, $clientlan);
    $serverlan == $_serverlan or die "Internal error, serverlan = $_serverlan != $serverlan\n";
    $dx = 1024 / ($S + 3);
    $posx = $top_x - $S * $dx / 2;
    $posy = $top_y - (defined $R ? $dy : 0);
    my @servers = ();
    my $serverno = 0;
    for (my $sn = 0; $sn < $S; $sn++) {
	$rspec .= <<"EOF";
  <node client_id="server$serverno" exclusive="true" component_manager_id="urn:publicid:IDN+wall2.ilabt.iminds.be+authority+cm">
    <sliver_type name="raw-pc">
      <disk_image name="urn:publicid:IDN+wall2.ilabt.iminds.be+image+emulab-ops:UBUNTU20-64-STD"/>
    </sliver_type>
    <jfed:ansible_group name="server"/>
    <location xmlns="http://jfed.iminds.be/rspec/ext/jfed/1" x="$posx" y="$posy"/>
    <interface client_id="server$serverno:if0">
      <ip address="10.0.$serverlan.$serverip" netmask="255.255.255.0" type="ipv4"/>
    </interface>
    <interface client_id="server$serverno:if1">
      <ip address="$pr4.$serverlan.$serverip" netmask="255.255.255.0" type="ipv4"/>
    </interface>
  </node>
EOF
	push @nodes, [ 'server', $serverno, $serverlan, $serverip ];
	push @servers, "server$serverno";
	$serverno++;
	$serverip++;
	$posx += $dx;
    }
    # now add a single server to direct the operation
    $serverip = 2;
    push @nodes, [ 'director', 0, $serverlan, $serverip ];
    $rspec .= <<"EOF";
  <node client_id="director0" exclusive="true" component_manager_id="urn:publicid:IDN+wall2.ilabt.iminds.be+authority+cm">
    <sliver_type name="raw-pc">
      <disk_image name="urn:publicid:IDN+wall2.ilabt.iminds.be+image+emulab-ops:UBUNTU20-64-STD"/>
    </sliver_type>
    <jfed:ansible_group name="director"/>
    <location xmlns="http://jfed.iminds.be/rspec/ext/jfed/1" x="$posx" y="$posy"/>
    <interface client_id="director0:if0">
      <ip address="10.0.$serverlan.$serverip" netmask="255.255.255.0" type="ipv4"/>
    </interface>
    <interface client_id="director0:if1">
      <ip address="$pr4.$serverlan.$serverip" netmask="255.255.255.0" type="ipv4"/>
    </interface>
  </node>
EOF
    push @servers, 'director0';
    $serverip++;
    $posx += $dx;
    # link servers with top level router or client LAN, as appropriate
    $rspec .= <<"EOF";
  <link client_id="link$linkno">
    <component_manager name="urn:publicid:IDN+wall2.ilabt.iminds.be+authority+cm"/>
EOF
    for my $s (@clients, @servers) {
	$rspec .= <<"EOF";
    <interface_ref client_id="$s:if1"/>
EOF
    }
    $rspec .= <<"EOF" if defined $R;
    <interface_ref client_id="router$top_router:if2"/>
EOF
    $rspec .= <<"EOF";
    <link_type name="lan"/>
  </link>
EOF

    # any keys?
    if (keys %K) {
	for my $U (sort keys %K) {
	  if ($U eq '') {
	      $rspec .= <<"EOF";
  <jfed-ssh-keys:user-ssh-keys>
EOF
	  } else {
	      $rspec .= <<"EOF";
  <jfed-ssh-keys:user-ssh-keys user="urn:publicid:IDN+ilabt.imec.be+user+$U">
EOF
	  }
	  for my $K (@{$K{$U}}) {
	      $rspec .= <<"EOF";
    <jfed-ssh-keys:sshkey>$K</jfed-ssh-keys:sshkey>
EOF
	  }
	  $rspec .= <<"EOF";
  </jfed-ssh-keys:user-ssh-keys>
EOF
      }
    }

    $rspec .= <<"EOF";
</rspec>
EOF
}

sub create_yaml {
    (my $r = $rspec) =~ s/^/      /gm;
    $r =~ s/\n+$//s;
    $yaml = <<"EOF";
---
action: RUN
actionOutputs:
- filename: $DIR/$EXP/output.txt
  format: TXT
  target: FILE
- filename: $DIR/$EXP/output.json
  format: JSON
  target: FILE
callOutputs:
- filename: $DIR/$EXP/apicalls.txt
  format: TEXT
  target: FILE
debugOutputs:
- filename: $DIR/$EXP/debug.txt
  format: TXT_FULL
  level: INFO
  target: FILE
experiment:
  provision:
    enabled: true
  requestRSpec:
    providedContentSource: |
$r
    source: PROVIDE_CONTENT
  slice:
    expireTimeMin: $TIME
    failIfNoProject: true
    sliceName: $EXP
  waitForReady:
    enabled: true
output:
  ansibleDir: $DIR/$EXP/ansible
  manifestFile: $DIR/$EXP/output.rspec
shareWith:
  projectMembers: true
user:
  pem:
  - /home/clc/data/login.pem
EOF
    defined $PWD or return;
    if ($PWD =~ m|^/|) {
	open(PWD, '<', $PWD) or die "$PWD: $!\n";
	$PWD = <PWD>;
	close PWD;
	defined $PWD or die "$PWD: empty file\n";
	chomp $PWD;
    }
    $yaml .= <<"EOF";
  password: $PWD
  passwordMethod: DIRECT
EOF
}

sub create_script {
    # "script" is really just a set of parameters for setup-experiment
    # create_rspec() already generated all IP addresses
    $script = '';
    my %routes = ();
    if (@routes) {
	for my $route (@routes) {
	    my ($route_to, $route_from, $router_ip) = @$route;
	    $routes{$route_from}{$route_to} = [ $route_from, $router_ip, 1 ];
	}
	# propagate routes across routers
	my $changed = 1;
	while ($changed) {
	    $changed = 0;
	    for my $route (@routes) {
		my ($route_via, $route_from, $router_ip) = @$route;
		for my $route_to (keys %{$routes{$route_via}}) {
		    $route_to == $route_from and next;
		    my $metric = 1 + $routes{$route_via}{$route_to}[2];
		    exists $routes{$route_from}{$route_to}
			&& $routes{$route_from}{$route_to}[2] <= $metric
			    and next;
		    $routes{$route_from}{$route_to} = [ $route_from, $router_ip, $metric ];
		    $changed = 1;
		}
	    }
	}
    }
    for my $node (@nodes) {
	my ($type, $number, @ips) = @$node;
	my %local = ();
	# IP addresses
	for (my ($i, $p) = (1, 0); $p < @ips; $i++, $p += 2) {
	    my $lan = $ips[$p];
	    my $addr = $ips[$p + 1];
	    $local{$lan} = undef;
	    $script .= sprintf "node %s %d if%d %s.%d.%d %s:%x::%x\n",
			       $type, $number, $i,
			       $pr4, $lan, $addr,
			       $pr6, $lan + $base6, $addr;
	}
	# static routes
	for (my $p = 0; $p < @ips; $p += 2) {
	    my $lan = $ips[$p];
	    my $addr = $ips[$p + 1];
	    for my $rt (sort { $a <=> $b } keys %{$routes{$lan}}) {
		exists $local{$rt} and next;
		my ($rl, $ra) = @{$routes{$lan}{$rt}};
		$rl == $lan && $ra == $addr and next;
		$script .= sprintf "rte4 %s %d %s.%d.0/24 %s.%d.%d\n",
				   $type, $number, $pr4, $rt, $pr4, $rl, $ra;
		$script .= sprintf "rte6 %s %d %s:%x::/64 %s:%x::%x\n",
				   $type, $number, $pr6, $rt + $base6,
						   $pr6, $rl + $base6, $ra;
	    }
	}
    }
}

