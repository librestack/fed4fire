#!/usr/bin/perl -w

use strict;
use POSIX 'strftime';
use FindBin '$Bin';

$| = 1;

my ($S, $R, $L, $RSPEC, $YAML, $SCRIPT, $PWD, %K, $EXP);
my $DIR = '/tmp';
-f "$Bin/../objects/id_rsa.pub" and unshift @ARGV, "K=$Bin/../objects/id_rsa.pub";
while (@ARGV) {
    my $A = shift @ARGV;
    $A =~ /^S=(.*)$/i and $S = $1, next;
    $A =~ /^R=(.*)$/i and $R = $1, next;
    $A =~ /^L=(.*)$/i and $L = $1, next;
    $A =~ /^RSPEC=(.*)$/i and $RSPEC = $1, next;
    $A =~ /^YAML=(.*)$/i and $YAML = $1, next;
    $A =~ /^SCRIPT=(.*)$/i and $SCRIPT = $1, next;
    $A =~ /^PWD=(.*)$/i and $PWD = $1, next;
    $A =~ /^EXP=(.*)$/i and $EXP = $1, next;
    $A =~ /^DIR=(.*)$/i and $DIR = $1, next;
    $A =~ /^K(\w*)=(.*)$/ or die "Unknown option $A\n";
    my ($user, $key) = ($1, $2);
    open(KF, '<', $key) or die "K=$key: $!\n";
    my $K = <KF>;
    close KF;
    defined $K or die "$A: empty key\n";
    chomp $K;
    push @{$K{$user}}, $K;
}
defined $S && defined $L or die "Missing S or L\n";
$S < 1 and die "S must be at least 1\n";
$L < 1 and die "L must be at least 1\n";
defined $R && $R < 1 and die "R must be at least 1\n";

if (! defined $EXP) {
    $EXP = "S$S";
    defined $R and $EXP .= "R$R";
    $EXP .= "L$L";
}

-d "$DIR/$EXP" or mkdir "$DIR/$EXP" || die "$DIR/$EXP: $!\n";
defined $RSPEC or $RSPEC = "$DIR/$EXP/action.rspec";
defined $YAML or $YAML = "$DIR/$EXP/action.yaml";
defined $SCRIPT or $SCRIPT = "$DIR/$EXP/action.script";

my $nLAN = defined $R ? (2 ** ($R - 1)) : 1;
my $rLAN = (defined $R && $R > 1) ? (2 ** ($R - 1) - 1) : 0;
my $C = $nLAN * $L;
# In theory we would be checking for overflow on $C aka "experiment so
# large you won't find enough hardware".

printf "Servers (S):        %8d\n", $S;
defined $R and printf "Router path (R):    %8d\n", $R;
defined $R and printf "Router LANs:        %8d\n", $rLAN;
printf "Client LANs:        %8d\n", $nLAN;
printf "Clente per LAN (L): %8d\n", $L;
printf "Total clients (C):  %8d\n", $C;
print "\n";

my ($rspec, $yaml, $script, @all);
create_rspec();
if (defined $RSPEC) {
    print "Creating rspec ($RSPEC)... ";
    open(RSPEC, '>', $RSPEC) or die "$RSPEC: $!\n";
    print RSPEC $rspec or die "$RSPEC: $!\n";
    close RSPEC or die "$RSPEC: $!\n";
    print "OK\n";
}
if (defined $YAML) {
    print "Creating yaml ($YAML)... ";
    create_yaml();
    open(YAML, '>', $YAML) or die "$YAML: $!\n";
    print YAML $yaml or die "$YAML: $!\n";
    close YAML or die "$YAML: $!\n";
    print "OK\n";
}
if (defined $SCRIPT) {
    print "Creating script ($SCRIPT)... ";
    create_script();
    open(SCRIPT, '>', $SCRIPT) or die "$SCRIPT: $!\n";
    print SCRIPT $script or die "$SCRIPT: $!\n";
    close SCRIPT or die "$SCRIPT: $!\n";
    print "OK\n";
}
exit 0;

sub create_rspec {
    # used in making up graph coordinates
    my $dx = 1024 / ($C + 1);
    my $dy = 512 / (($R || 0) + 3);
    # OK, make up the rspec
    (my $now = strftime '%Y-%m-%dT%H:%M:%S.000%z', gmtime) =~ s/(\d{2})$/:$1/;
    $rspec = <<"EOF";
<?xml version="1.0" encoding="UTF-8"?>
<rspec
  xmlns="http://www.geni.net/resources/rspec/3"
  type="request"
  generated="$now"
  xmlns:emulab="http://www.protogeni.net/resources/rspec/ext/emulab/1"
  xmlns:delay="http://www.protogeni.net/resources/rspec/ext/delay/1"
  xmlns:jfed-command="http://jfed.iminds.be/rspec/ext/jfed-command/1"
  xmlns:client="http://www.protogeni.net/resources/rspec/ext/client/1"
  xmlns:jfed-ssh-keys="http://jfed.iminds.be/rspec/ext/jfed-ssh-keys/1"
  xmlns:jfed="http://jfed.iminds.be/rspec/ext/jfed/1"
  xmlns:sharedvlan="http://www.protogeni.net/resources/rspec/ext/shared-vlan/1"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.geni.net/resources/rspec/3 http://www.geni.net/resources/rspec/3/manifest.xsd "
  >
EOF
    my $ipstart = 8;
    my $netstart = 0;
    my $clientlan = $netstart;
    my $routerlan = $clientlan + $nLAN;
    my $serverlan = defined $R ? ($routerlan + $rLAN) : $clientlan;
    my $serverip = $ipstart;
    my $routerip = 4;
    my $linkno = 0;
    my $posx = $dx;
    my $posy = 512;
    my @routers = ();
    my $routerno = 0;

    # add all clients and bottom level routers and link them together
    # we link using the second interface, as the first interface is the
    # control interface where we aren't supposed to have experiment traffic
    my @clients = ();
    my $clientno = 0;
    for (my $ln = 0; $ln < $nLAN; $ln++) {
	my $rx = 0;
	my $clientip = $ipstart;
	for (my $cn = 0; $cn < $L; $cn++) {
	    # add client
	    $rspec .= <<"EOF";
  <node client_id="client$clientno" exclusive="true" component_manager_id="urn:publicid:IDN+wall2.ilabt.iminds.be+authority+cm">
    <sliver_type name="raw-pc">
      <disk_image name="urn:publicid:IDN+wall2.ilabt.iminds.be+image+emulab-ops:UBUNTU20-64-STD"/>
    </sliver_type>
    <jfed:ansible_group name="client"/>
    <location xmlns="http://jfed.iminds.be/rspec/ext/jfed/1" x="$posx" y="$posy"/>
    <interface client_id="client$clientno:if0">
      <ip address="10.0.$clientlan.$clientip" netmask="255.255.255.0" type="ipv4"/>
    </interface>
    <interface client_id="client$clientno:if1">
      <ip address="192.168.$clientlan.$clientip" netmask="255.255.255.0" type="ipv4"/>
    </interface>
  </node>
EOF
	    my $v6lan = sprintf "%02x", $clientlan - $netstart;
	    push @all, "client $clientno if1 192.168.$clientlan.$clientip "
		     . "2a03:4980:123:9a$v6lan\::$clientip";
	    push @clients, "client$clientno";
print "C$clientno $clientlan.$clientip\n"; # XXX
	    $clientno++;
	    $rx += $posx;
	    $posx += $dx;
	    $clientip++;
	    defined $R or $serverip++;
	}
	defined $R or next;
	$rx /= $L;
	# add router
	my $v6lan = sprintf "%02x", $clientlan - $netstart;
	push @all, "router $routerno if1 192.168.$clientlan.1 "
		 . "2a03:4980:123:9a$v6lan\::1";
	$v6lan = sprintf "%02x", $routerlan - $netstart;
	push @all, "router $routerno if2 192.168.$routerlan.$routerip "
		 . "2a03:4980:123:9a$v6lan\::$routerip";
	my $py = $posy - $dy;
	push @routers, [$routerno, $rx, $py, $routerlan];
print "R$routerno $clientlan.1\n"; # XXX
print "R$routerno $routerlan.$routerip\n"; # XXX
	$rspec .= <<"EOF";
  <node client_id="router$routerno" exclusive="true" component_manager_id="urn:publicid:IDN+pllab.pl+authority+cm">
    <sliver_type name="raw-router"/>
    <location xmlns="http://jfed.iminds.be/rspec/ext/jfed/1" x="$rx" y="$py"/>
    <interface client_id="router$routerno:if0">
      <ip address="10.0.$clientlan.1" netmask="255.255.255.0" type="ipv4"/>
    </interface>
    <interface client_id="router$routerno:if1">
      <ip address="192.168.$clientlan.1" netmask="255.255.255.0" type="ipv4"/>
    </interface>
    <interface client_id="router$routerno:if2">
      <ip address="192.168.$routerlan.$routerip" netmask="255.255.255.0" type="ipv4"/>
    </interface>
  </node>
EOF
	# add links client <-> router
	$rspec .= <<"EOF";
  <link client_id="link$linkno">
    <component_manager name="urn:publicid:IDN+wall2.ilabt.iminds.be+authority+cm"/>
    <component_manager name="urn:publicid:IDN+pllab.pl+authority+cm"/>
EOF
	for my $c (@clients) {
	    $rspec .= <<"EOF";
    <interface_ref client_id="$c:if1"/>
EOF
	}
	$rspec .= <<"EOF";
    <interface_ref client_id="router$routerno:if1"/>
    <link_type name="lan"/>
EOF
	for my $c (@clients) {
	    $rspec .= <<"EOF";
    <property source_id="$c:if1" dest_id="router$routerno:if1" capacity="10000"/>
    <property source_id="router$routerno:if1" dest_id="$c:if1" capacity="10000"/>
EOF
	}
	$rspec .= <<"EOF";
  </link>
EOF
	$routerno++;
	@clients = ();
	$linkno++;
	$clientlan++;
	$routerip++;
	$routerip < 6 and next;
	$routerip = 4;
	$routerlan++;
    }

    if (defined $R) {
	# now add routers until there's just one left, where we'll attach the servers
	while (@routers > 1) {
	    my @or = @routers;
	    @routers = ();
	    while (@or) {
		# join two routers with a router bwteen them
		my ($r1, $x1, $y1, $l1) = @{shift @or};
		my ($r2, $x2, $y2, $l2) = @{shift @or};
		$l1 == $l2 or die "Internal error on router LAN: $l1 != $l2\n";
		my $rx = ($x1 + $x2) / 2;
		my $ry = $y1 - $dx;
		my $v6lan = sprintf "%02x", $l1 - $netstart;
		push @all, "router $routerno if1 192.168.$l1.1 "
			 . "2a03:4980:123:9a$v6lan\::1";
		$v6lan = sprintf "%02x", $routerlan - $netstart;
		push @all, "router $routerno if2 192.168.$routerlan.$routerip "
			 . "2a03:4980:123:9a$v6lan\::$routerip";
		push @routers, [$routerno, $rx, $ry, $routerlan];
print "R$routerno $l1.1\n"; # XXX
print "R$routerno $routerlan.$routerip\n"; # XXX
		$rspec .= <<"EOF";
  <node client_id="router$routerno" exclusive="true" component_manager_id="urn:publicid:IDN+pllab.pl+authority+cm">
    <sliver_type name="raw-router"/>
    <location xmlns="http://jfed.iminds.be/rspec/ext/jfed/1" x="$rx" y="$ry"/>
    <interface client_id="router$routerno:if0">
      <ip address="10.0.$l1.1" netmask="255.255.255.0" type="ipv4"/>
    </interface>
    <interface client_id="router$routerno:if1">
      <ip address="192.168.$l1.1" netmask="255.255.255.0" type="ipv4"/>
    </interface>
    <interface client_id="router$routerno:if2">
      <ip address="192.168.$routerlan.$routerip" netmask="255.255.255.0" type="ipv4"/>
    </interface>
  </node>
  <link client_id="link$linkno">
    <component_manager name="urn:publicid:IDN+pllab.pl+authority+cm"/>
    <interface_ref client_id="router$r1:if2"/>
    <interface_ref client_id="router$r2:if2"/>
    <interface_ref client_id="router$routerno:if1"/>
    <link_type name="lan"/>
  </link>
EOF
		$linkno++;
		$routerno++;
		$routerip++;
		$routerip < 6 and next;
		$routerip = 4;
		$routerlan++;
	    }
	}
    }

    # add the servers
    my ($top_router, $top_x, $top_y, $_serverlan) =
	defined $R ? @{shift @routers} : (undef, 512, 256, $clientlan);
    $serverlan == $_serverlan or die "Internal error, serverlan = $_serverlan != $serverlan\n";
    $dx = 1024 / ($S + 3);
    $posx = $top_x - $S * $dx / 2;
    $posy = $top_y - (defined $R ? $dy : 0);
    my @servers = ();
    my $serverno = 0;
    for (my $sn = 0; $sn < $S; $sn++) {
	$rspec .= <<"EOF";
  <node client_id="server$serverno" exclusive="true" component_manager_id="urn:publicid:IDN+wall2.ilabt.iminds.be+authority+cm">
    <sliver_type name="raw-pc">
      <disk_image name="urn:publicid:IDN+wall2.ilabt.iminds.be+image+emulab-ops:UBUNTU20-64-STD"/>
    </sliver_type>
    <jfed:ansible_group name="server"/>
    <location xmlns="http://jfed.iminds.be/rspec/ext/jfed/1" x="$posx" y="$posy"/>
    <interface client_id="server$serverno:if0">
      <ip address="10.0.$serverlan.$serverip" netmask="255.255.255.0" type="ipv4"/>
    </interface>
    <interface client_id="server$serverno:if1">
      <ip address="192.168.$serverlan.$serverip" netmask="255.255.255.0" type="ipv4"/>
    </interface>
  </node>
EOF
	my $v6lan = sprintf "%02x", $serverlan - $netstart;
	push @all, "server $serverno if1 192.168.$serverlan.$serverip "
		 . "2a03:4980:123:9a$v6lan\::$serverip";
	push @servers, "server$serverno";
print "S$serverno $serverlan.$serverip\n"; # XXX
	$serverno++;
	$serverip++;
	$posx += $dx;
    }
    # now add a single server to direct the operation
    $serverip = 2;
    my $v6lan = sprintf "%02x", $serverlan - $netstart;
    push @all, "director 0 if1 192.168.$serverlan.$serverip "
	     . "2a03:4980:123:9a$v6lan\::$serverip";
print "D0 $serverlan.$serverip\n"; # XXX
    $rspec .= <<"EOF";
  <node client_id="director0" exclusive="true" component_manager_id="urn:publicid:IDN+wall2.ilabt.iminds.be+authority+cm">
    <sliver_type name="raw-pc">
      <disk_image name="urn:publicid:IDN+wall2.ilabt.iminds.be+image+emulab-ops:UBUNTU20-64-STD"/>
    </sliver_type>
    <jfed:ansible_group name="director"/>
    <location xmlns="http://jfed.iminds.be/rspec/ext/jfed/1" x="$posx" y="$posy"/>
    <interface client_id="director0:if0">
      <ip address="10.0.$serverlan.$serverip" netmask="255.255.255.0" type="ipv4"/>
    </interface>
    <interface client_id="director0:if1">
      <ip address="192.168.$serverlan.$serverip" netmask="255.255.255.0" type="ipv4"/>
    </interface>
  </node>
EOF
    push @servers, 'director0';
    $serverip++;
    $posx += $dx;
    # link servers with top level router or client LAN, as appropriate
    $rspec .= <<"EOF";
  <link client_id="link$linkno">
    <component_manager name="urn:publicid:IDN+wall2.ilabt.iminds.be+authority+cm"/>
EOF
    $rspec .= <<"EOF" if defined $R;
    <component_manager name="urn:publicid:IDN+pllab.pl+authority+cm"/>
EOF
    for my $s (@clients, @servers) {
	$rspec .= <<"EOF";
    <interface_ref client_id="$s:if1"/>
EOF
    }
    $rspec .= <<"EOF" if defined $R;
    <interface_ref client_id="router$top_router:if2"/>
EOF
    $rspec .= <<"EOF";
    <link_type name="lan"/>
EOF
    if (defined $R) {
	for my $s (@servers) {
	    $rspec .= <<"EOF";
    <property source_id="$s:if1" dest_id="router$top_router:if2" capacity="10000"/>
    <property source_id="router$top_router:if2" dest_id="$s:if1" capacity="10000"/>
EOF
	}
    }
    $rspec .= <<"EOF";
  </link>
EOF

    # any keys?
    if (keys %K) {
	for my $U (sort keys %K) {
	  if ($U eq '') {
	      $rspec .= <<"EOF";
  <jfed-ssh-keys:user-ssh-keys>
EOF
	  } else {
	      $rspec .= <<"EOF";
  <jfed-ssh-keys:user-ssh-keys user="urn:publicid:IDN+ilabt.imec.be+user+$U">
EOF
	  }
	  for my $K (@{$K{$U}}) {
	      $rspec .= <<"EOF";
    <jfed-ssh-keys:sshkey>$K</jfed-ssh-keys:sshkey>
EOF
	  }
	  $rspec .= <<"EOF";
  </jfed-ssh-keys:user-ssh-keys>
EOF
      }
    }

    $rspec .= <<"EOF";
</rspec>
EOF
}

sub create_yaml {
    (my $r = $rspec) =~ s/^/      /gm;
    $r =~ s/\n+$//s;
    $yaml = <<"EOF";
---
action: RUN
actionOutputs:
- filename: $DIR/$EXP/output.txt
  format: TXT
  target: FILE
- filename: $DIR/$EXP/output.json
  format: JSON
  target: FILE
callOutputs:
- filename: $DIR/$EXP/apicalls.txt
  format: TEXT
  target: FILE
debugOutputs:
- filename: $DIR/$EXP/debug.txt
  format: TXT_FULL
  level: INFO
  target: FILE
experiment:
  provision:
    enabled: true
  requestRSpec:
    providedContentSource: |
$r
    source: PROVIDE_CONTENT
  slice:
    expireTimeMin: 120
    failIfNoProject: true
    sliceName: $EXP
  waitForReady:
    enabled: true
output:
  ansibleDir: $DIR/$EXP/ansible
  manifestFile: $DIR/$EXP/output.rspec
shareWith:
  projectMembers: true
user:
  pem:
  - /home/clc/data/login.pem
EOF
    defined $PWD or return;
    if ($PWD =~ m|^/|) {
	open(PWD, '<', $PWD) or die "$PWD: $!\n";
	$PWD = <PWD>;
	close PWD;
	defined $PWD or die "$PWD: empty file\n";
	chomp $PWD;
    }
    $yaml .= <<"EOF";
  password: $PWD
  passwordMethod: DIRECT
EOF
}

sub create_script {
    # "script" is really just a set of parameters for setup-experiment
    $script = join("\n", @all, '');
}

