#!/usr/bin/perl -w

use strict;
use DBI;
use File::Temp 'tempdir';

my $usage = "Usage: $0 [-amnr] DATA_NAME CACHE_DB REPORT_TARBALL [...]\n";
my $raw_data = 0;
my $sort_num = 1;
my $sort_index = 1;
while (@ARGV && $ARGV[0] =~ /^-+(.*)$/) {
    my $opts = $1;
    shift @ARGV;
    $opts eq '' and last;
    while ($opts =~ s/^(.)//) {
	my $opt = $1;
	$opt eq 'a' and $sort_num = 1, $sort_index = 1, next;
	$opt eq 'm' and $sort_num = 1, $sort_index = 4, next;
	$opt eq 'n' and $sort_num = 0, $sort_index = 0, next;
	$opt eq 'r' and $raw_data = 1, next;
	die $usage;
    }
}
@ARGV >= 3 or die $usage;
my $dataname = shift @ARGV;
my $cache_db = shift @ARGV;

my %dataname = (
    'run-time' => [
	qr/^client\d+\./,
	\&init_runtime,
	\&get_runtime,
	\&finish_runtime,
	3,
	1,
    ],
);

exists $dataname{$dataname}
    or die "Unknown DATA_NAME, known are " . join(' ', sort keys %dataname) . "\n";
my ($file_regex, $init_code, $get_code, $finish_code, $decimals, $is_time) =
    @{$dataname{$dataname}};
my $fmt_std = '%' . ($decimals ? (($decimals + 5) . ".${decimals}f") : "${decimals}d");
my $fmt_whole = '%' . ($decimals ? (($decimals + 9) . ".${decimals}f") : "${decimals}d");
my $fmt_seconds = '%0' . ($decimals ? (($decimals + 3) . ".${decimals}f") : "2d");

my $dbh = DBI->connect("dbi:SQLite:dbname=$cache_db", '', '',
		       { RaiseError => 1, AutoCommit => 1 });

run_sql(<<EOF);
CREATE TABLE IF NOT EXISTS tarballs (
    filename VARCHAR(256),
    mtime INTEGER,
    dataname VARCHAR(256),
    count INTEGER,
    min FLOAT,
    max FLOAT,
    total FLOAT,
    square FLOAT
);
EOF

run_sql(<<EOF);
CREATE INDEX IF NOT EXISTS tarballs_name
ON tarballs(filename, dataname);
EOF

my $get_cached = $dbh->prepare(<<EOF);
SELECT mtime, count, min, max, total, square
FROM tarballs
WHERE filename = ?
  AND dataname = ?;
EOF

my $delete_cached = $dbh->prepare(<<EOF);
DELETE
FROM tarballs
WHERE filename = ?
  AND dataname = ?;
EOF

my $add_cached = $dbh->prepare(<<EOF);
INSERT INTO tarballs
(filename, dataname, mtime, count, min, max, total, square)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
EOF

my %counts = ();
for my $tb (@ARGV) {
    stat $tb or die "$tb: $!\n";
    my $tmtime = (stat _)[9];
    $tb =~ /:\d+-(multicast|scp|tcp|udp)-(immediate|random|random2)-(\d+)-\d+\.tar\.gz$/
	or die "Unrecognised tarball name: $tb\n";
    my $title = sprintf "%-9s %-9s %4d", $1, $2, $3;
    (my $idxtb = $tb) =~ s!^.*/!!;
    # check if this file is already cached
    my ($cmtime, $count, $min, $max, $total, $square) =
	$dbh->selectrow_array($get_cached, {}, $idxtb, $dataname);
    if (! defined $cmtime || $cmtime != $tmtime) {
	# not cached, or out of date, so read this tarball
	defined $cmtime and $delete_cached->execute($idxtb, $dataname);
	my $dir = tempdir(CLEANUP => 1) or die "tmpdir: $!\n";
	my $ptb = $tb =~ m!^/! ? $tb : "./$tb";
	run_cmd("tar $tb", 'tar', 'xf', $ptb, '-C', $dir);
	opendir(DIR, $dir) or die "$dir: $!\n";
	($total, $square, $count, $min, $max) = (0, 0, 0);
	while (defined (my $ent = readdir DIR)) {
	    $ent =~ $file_regex or next;
	    run_cmd("lwmon ($tb)/$ent", 'lwmon', '-traw', '-R', "$dir/$ent", "-P$dir/lwmon");
	    open(LWMON, '<', "$dir/lwmon") or die "($tb,$ent)/lwmon: $!\n";
	    my %data;
	    $init_code->(\%data);
	    while (<LWMON>) {
		$get_code->($tb, $ent, \%data, $_);
	    }
	    close LWMON;
	    my ($fcount, $ftotal, $fsquare, $fmin, $fmax) =
		$finish_code->($tb, $ent, \%data);
	    $count += $fcount;
	    $total += $ftotal;
	    $square += $fsquare;
	    defined $min && $min <= $fmin or $min = $fmin;
	    defined $max && $max >= $fmax or $max = $fmax;
	}
	closedir DIR;
	$count > 0 or die "$tb: no data\n";
	$add_cached->execute($idxtb, $dataname, $tmtime,
			     $count, $min, $max, $total, $square);
    }
    if (exists $counts{$title}) {
	$counts{$title}[0] += $count;
	$counts{$title}[1] += $total;
	$counts{$title}[2] += $square;
	$counts{$title}[3] > $min and $counts{$title}[3] = $min;
	$counts{$title}[4] < $max and $counts{$title}[4] = $max;
    } else {
	$counts{$title} = [$count, $total, $square, $min, $max];
    }
}

my @results;
for my $title (keys %counts) {
    my ($count, $total, $square, $min, $max) = @{$counts{$title}};
    my $avg = $total / $count;
    my $std = '-';
    if ($count > 1) {
	my $var = ($square - 2 * $avg * $total + $avg * $avg * $count)
		/ ($count - 1);
	# avoid square root of "-0"
	$var < 0 && $var > -1e-10 and $var = 0;
	$std = sqrt($var);
	$std = sprintf $fmt_std, $std;
    }
    push @results, [$title, $avg, $count, $min, $max, $std];
}

my $space_data = length(sprintf $fmt_whole, 0);
my $space_std = length(sprintf $fmt_std, 0);
printf "%-9s %-9s %4s %${space_data}s %5s %${space_data}s %${space_data}s %${space_std}s\n",
       qw(UPDATE SCHEDULE SIZE AVG COUNT MIN MAX STD);
my @sorted;
if ($sort_num) {
    @sorted = sort { $a->[$sort_index] <=> $b->[$sort_index] ||
		     $a->[0] cmp $b->[0] } @results;
} else {
    @sorted = sort { $a->[$sort_index] cmp $b->[$sort_index] ||
		     $a->[0] cmp $b->[0] } @results;
}
for my $result (@sorted) {
    my ($title, $avg, $count, $min, $max, $std) = @$result;
    my $time = fmt_data($avg);
    $count = sprintf "%5d", $count;
    $min = fmt_data($min);
    $max = fmt_data($max);
    print "$title $time $count $min $max $std\n";
}

$dbh->disconnect();

sub fmt_data {
    my ($sec) = @_;
    $raw_data || ! $is_time || $sec < 60 and return sprintf $fmt_whole, $sec;
    my $m = int($sec / 60);
    $sec = sprintf $fmt_seconds, $sec - $m * 60;
    if ($m < 60) {
	return sprintf "%5d:%s", $m, $sec;
    } else {
	return sprintf "%2d:%02d:%s", int($m / 60), $m % 60, $sec;
    }
}

sub run_cmd {
    my ($name, @cmd) = @_;
    system(@cmd) == 0 and return;
    $? == -1 and die "$name: $!\n";
    $? & 0x7f and die "$name: killed by signal " . ($? & 0x7f) . "\n";
    die "$name: exited with status " . ($? >> 8) . "\n";
}

sub run_sql {
    my ($query) = @_;
    $dbh->do($query) || die "$query\n" . $dbh->errstr . "\n";
}

sub init_runtime {
    my ($data) = @_;
    $data->{time} = 0;
    $data->{place} = 0;
    $data->{any} = 0;
}

sub get_runtime {
    my ($tb, $ent, $data, $line) = @_;
    $line =~ /\bclient_\w+ \(log entry\) (start|end)/ or return;
    my $what = $1;
    /^(\d+(?:\.\d+)?)\s/ or return;
    my $time = $1;
    if ($what eq 'start') {
	$data->{place} and die "$tb ($ent): misplaced start\n";
	$data->{place} = 1;
	$data->{time} -= $time;
    } else {
	$data->{place} or die "$tb ($ent): misplaced end\n";
	$data->{place} = 0;
	$data->{time} += $time;
	$data->{any} = 1;
    }
}

sub finish_runtime {
    my ($tb, $ent, $data) = @_;
    $data->{place} and die "$tb ($ent): missing end\n";
    $data->{any} or die "$tb ($ent): no start/end logs\n";
    my $time = $data->{time};
    return (1, $time, $time * $time, $time, $time);
}

