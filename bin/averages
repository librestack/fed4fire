#!/usr/bin/perl -w

use strict;
use DBI;
use FindBin '$Bin';
use File::Temp 'tempdir';
use File::Path 'remove_tree';
use lib "$Bin/../perl";
use Lwmon;

my $usage = "Usage: $0 [-amnr] DATA_NAME CACHE_DB REPORT_TARBALL [...]\n";
my $raw_data = 0;
my $sort_num = 1;
my $sort_index = 1;
while (@ARGV && $ARGV[0] =~ /^-+(.*)$/) {
    my $opts = $1;
    shift @ARGV;
    $opts eq '' and last;
    while ($opts =~ s/^(.)//) {
	my $opt = $1;
	$opt eq 'a' and $sort_num = 1, $sort_index = 1, next;
	$opt eq 'm' and $sort_num = 1, $sort_index = 4, next;
	$opt eq 'n' and $sort_num = 0, $sort_index = 0, next;
	$opt eq 'r' and $raw_data = 1, next;
	die $usage;
    }
}
@ARGV >= 3 or die $usage;
my $dataname = shift @ARGV;
my $cache_db = shift @ARGV;

my %dataname = (
    'run-time' => {
	file_regex  => qr/^client\d+\./,
	init_code   => \&init_runtime,
	finish_code => \&finish_runtime,
	decimals    => 3,
	is_time     => 1,
	types       => {
	    65534   => \&get_runtime,
	},
    },
);

exists $dataname{$dataname}
    or die "Unknown DATA_NAME, known are " . join(' ', sort keys %dataname) . "\n";
my $file_regex = $dataname{$dataname}{file_regex};
my $init_code = $dataname{$dataname}{init_code};
my $finish_code = $dataname{$dataname}{finish_code};
my $decimals = $dataname{$dataname}{decimals};
my $is_time = $dataname{$dataname}{is_time};
my $types = $dataname{$dataname}{types};

my $fmt_std = '%' . ($decimals ? (($decimals + 5) . ".${decimals}f") : "${decimals}d");
my $fmt_whole = '%' . ($decimals ? (($decimals + 9) . ".${decimals}f") : "${decimals}d");
my $fmt_seconds = '%0' . ($decimals ? (($decimals + 3) . ".${decimals}f") : "2d");

my $dbh = DBI->connect("dbi:SQLite:dbname=$cache_db", '', '',
		       { RaiseError => 1, AutoCommit => 1 });

run_sql(<<EOF);
CREATE TABLE IF NOT EXISTS tarballs (
    id INTEGER NOT NULL PRIMARY KEY,
    filename VARCHAR(256),
    filesize INTEGER,
    mtime INTEGER
);
EOF

run_sql(<<EOF);
CREATE INDEX IF NOT EXISTS tarballs_name
ON tarballs(filename);
EOF

run_sql(<<EOF);
CREATE TABLE IF NOT EXISTS data (
    tar_id INTEGER NOT NULL,
    dataname VARCHAR(256),
    count INTEGER,
    min FLOAT,
    max FLOAT,
    total FLOAT,
    square FLOAT
);
EOF

run_sql(<<EOF);
CREATE INDEX IF NOT EXISTS data_id
ON data(tar_id, dataname)
EOF

run_sql(<<EOF);
CREATE INDEX IF NOT EXISTS data_name
ON data(dataname, tar_id)
EOF

my $find_tarball = $dbh->prepare(<<EOF);
SELECT id, filesize, mtime
FROM tarballs
WHERE filename = ?;
EOF

my $delete_tarball = $dbh->prepare(<<EOF);
DELETE FROM tarballs WHERE id = ?;
EOF

my $delete_data = $dbh->prepare(<<EOF);
DELETE FROM data WHERE tar_id = ?;
EOF

my $max_tar_id = $dbh->prepare(<<EOF);
SELECT max(id) FROM tarballs;
EOF

my $add_tarball = $dbh->prepare(<<EOF);
INSERT INTO tarballs
(id, filename, filesize, mtime)
VALUES (?, ?, ?, ?);
EOF

my $get_data = $dbh->prepare(<<EOF);
SELECT count, min, max, total, square
FROM data
WHERE tar_id = ?
  AND dataname = ?;
EOF

my $add_data = $dbh->prepare(<<EOF);
INSERT INTO data
(tar_id, dataname, count, min, max, total, square)
VALUES (?, ?, ?, ?, ?, ?, ?)
EOF

my $dir;
END { defined $dir and remove_tree($dir); undef $dir; }

my %counts = ();
for my $tb (@ARGV) {
    stat $tb or die "$tb: $!\n";
    my $tfilesize = (stat _)[7];
    my $tmtime = (stat _)[9];
    $tb =~ /:\d+-(multicast|scp|tcp|udp)-(immediate|random|random2)-(\d+)-\d+\.tar\.gz$/
	or die "Unrecognised tarball name: $tb\n";
    my $title = sprintf "%-9s %-9s %4d", $1, $2, $3;
    (my $tfilename = $tb) =~ s!^.*/!!;
    # check if we already have this tarball and it is up to date
    my ($id, $cfilesize, $cmtime) = $dbh->selectrow_array($find_tarball, {}, $tfilename);
    if (! defined $cmtime || $cmtime != $tmtime || $cfilesize != $tfilesize) {
	if (defined $cmtime) {
	    $delete_tarball->execute($tfilename, $id);
	    $delete_data->execute($tfilename, $id);
	} else {
	    ($id) = 1 + ($dbh->selectrow_array($max_tar_id, {}) || 0);
	}
	$add_tarball->execute($id, $tfilename, $tfilesize, $tmtime);
    }
    # check if the data is already cached
    my ($count, $min, $max, $total, $square) =
	$dbh->selectrow_array($get_data, {}, $id, $dataname);
    if (! defined $count) {
	# not cached
	$dir = tempdir() or die "tmpdir: $!\n";
	my $ptb = $tb =~ m!^/! ? $tb : "./$tb";
	run_cmd("tar $tb", 'tar', 'xf', $ptb, '-C', $dir);
	opendir(DIR, $dir) or die "$dir: $!\n";
	($total, $square, $count, $min, $max) = (0, 0, 0);
	while (defined (my $ent = readdir DIR)) {
	    $ent =~ $file_regex or next;
	    my $lwmon = Lwmon->new("$dir/$ent");
	    my %data;
	    $init_code->(\%data);
	    while (defined (my $packet = $lwmon->nextrecord)) {
		for my $item (@{$packet->{data}}) {
		    exists $types->{$item->{type}} or next;
		    my $code = $types->{$item->{type}};
		    $code->($tb, $ent, \%data, $packet, $item);
		}
	    }
	    my ($fcount, $ftotal, $fsquare, $fmin, $fmax) =
		$finish_code->($tb, $ent, \%data);
	    $count += $fcount;
	    $total += $ftotal;
	    $square += $fsquare;
	    defined $min && $min <= $fmin or $min = $fmin;
	    defined $max && $max >= $fmax or $max = $fmax;
	}
	closedir DIR;
	$count > 0 or die "$tb: no data\n";
	$add_data->execute($id, $dataname, $count, $min, $max, $total, $square);
	remove_tree($dir);
	undef $dir;
    }
    if (exists $counts{$title}) {
	$counts{$title}[0] += $count;
	$counts{$title}[1] += $total;
	$counts{$title}[2] += $square;
	$counts{$title}[3] > $min and $counts{$title}[3] = $min;
	$counts{$title}[4] < $max and $counts{$title}[4] = $max;
    } else {
	$counts{$title} = [$count, $total, $square, $min, $max];
    }
}

my @results;
for my $title (keys %counts) {
    my ($count, $total, $square, $min, $max) = @{$counts{$title}};
    my $avg = $total / $count;
    my $std = '-';
    if ($count > 1) {
	my $var = ($square - 2 * $avg * $total + $avg * $avg * $count)
		/ ($count - 1);
	# avoid square root of "-0"
	$var < 0 && $var > -1e-10 and $var = 0;
	$std = sqrt($var);
	$std = sprintf $fmt_std, $std;
    }
    push @results, [$title, $avg, $count, $min, $max, $std];
}

my $space_data = length(sprintf $fmt_whole, 0);
my $space_std = length(sprintf $fmt_std, 0);
printf "%-9s %-9s %4s %${space_data}s %5s %${space_data}s %${space_data}s %${space_std}s\n",
       qw(UPDATE SCHEDULE SIZE AVG COUNT MIN MAX STD);
my @sorted;
if ($sort_num) {
    @sorted = sort { $a->[$sort_index] <=> $b->[$sort_index] ||
		     $a->[0] cmp $b->[0] } @results;
} else {
    @sorted = sort { $a->[$sort_index] cmp $b->[$sort_index] ||
		     $a->[0] cmp $b->[0] } @results;
}
for my $result (@sorted) {
    my ($title, $avg, $count, $min, $max, $std) = @$result;
    my $time = fmt_data($avg);
    $count = sprintf "%5d", $count;
    $min = fmt_data($min);
    $max = fmt_data($max);
    print "$title $time $count $min $max $std\n";
}

$dbh->disconnect();

sub fmt_data {
    my ($sec) = @_;
    $raw_data || ! $is_time || $sec < 60 and return sprintf $fmt_whole, $sec;
    my $m = int($sec / 60);
    $sec = sprintf $fmt_seconds, $sec - $m * 60;
    if ($m < 60) {
	return sprintf "%5d:%s", $m, $sec;
    } else {
	return sprintf "%2d:%02d:%s", int($m / 60), $m % 60, $sec;
    }
}

sub run_cmd {
    my ($name, @cmd) = @_;
    system(@cmd) == 0 and return;
    $? == -1 and die "$name: $!\n";
    $? & 0x7f and die "$name: killed by signal " . ($? & 0x7f) . "\n";
    die "$name: exited with status " . ($? >> 8) . "\n";
}

sub run_sql {
    my ($query) = @_;
    $dbh->do($query) || die "$query\n" . $dbh->errstr . "\n";
}

sub init_runtime {
    my ($data) = @_;
    $data->{time} = 0;
    $data->{place} = 0;
    $data->{any} = 0;
}

sub get_runtime {
    my ($tb, $ent, $data, $packet, $item) = @_;
    exists $item->{name} or return;
    $item->{name} =~ /^client_/ or return;
    exists $item->{parm} or return;
    my $time = $packet->{timestamp};
    if ($item->{parm} eq 'start') {
	$data->{place} and die "$tb ($ent): misplaced start\n";
	$data->{place} = 1;
	$data->{time} -= $time;
    } elsif ($item->{parm} eq 'end') {
	$data->{place} or die "$tb ($ent): misplaced end\n";
	$data->{place} = 0;
	$data->{time} += $time;
	$data->{any} = 1;
    }
}

sub finish_runtime {
    my ($tb, $ent, $data) = @_;
    $data->{place} and die "$tb ($ent): missing end\n";
    $data->{any} or die "$tb ($ent): no start/end logs\n";
    my $time = $data->{time};
    return (1, $time, $time * $time, $time, $time);
}

