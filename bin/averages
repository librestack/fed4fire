#!/usr/bin/perl -w

use strict;
use DBI;
use FindBin '$Bin';
use File::Temp 'tempdir';
use File::Path 'remove_tree';
use lib "$Bin/../perl";
use Experiment;
use Lwmon;

my $usage = "Usage: $0 [-acmnr] DATA_NAME CACHE_DB REPORT_TARBALL [...]\n";
my $raw_data = 0;
my $sort_num = 1;
my $sort_index = 1;
while (@ARGV && $ARGV[0] =~ /^-+(.*)$/) {
    my $opts = $1;
    shift @ARGV;
    $opts eq '' and last;
    while ($opts =~ s/^(.)//) {
	my $opt = $1;
	$opt eq 'a' and $sort_num = 1, $sort_index = 1, next;
	$opt eq 'c' and $sort_num = undef, next;
	$opt eq 'm' and $sort_num = 1, $sort_index = 4, next;
	$opt eq 'n' and $sort_num = 0, $sort_index = 0, next;
	$opt eq 'r' and $raw_data = 1, next;
	die $usage;
    }
}
@ARGV >= 3 or die $usage;
my $dataname = shift @ARGV;
my $cache_db = shift @ARGV;

my %dataname = (
    'run-time' => {
	file_regex  => qr/^client\d+\./,
	init_code   => \&init_runtime,
	finish_code => \&finish_runtime,
	decimals    => 3,
	is_time     => 1,
	mode        => 'data',
	types       => {
	    65534   => \&get_runtime,
	},
    },
    'server-tx' => {
	file_regex  => qr/^server\d+\./,
	init_code   => undef,
	finish_code => \&finish_values,
	decimals    => 1,
	is_time     => 0,
	mode        => 'summary',
	types       => {
	    6       => { if1 => sub { get_value(1, 0, 1e-3, @_) }, },
	},
    },
    'server-load' => {
	file_regex  => qr/^server\d+\./,
	init_code   => undef,
	finish_code => \&finish_values,
	decimals    => 1,
	is_time     => 0,
	mode        => 'summary',
	types       => {
	    4       => sub { get_value(0, undef, 1e-2, @_) },
	},
    },
);

exists $dataname{$dataname}
    or die "Unknown DATA_NAME, known are " . join(' ', sort keys %dataname) . "\n";
my $file_regex = $dataname{$dataname}{file_regex};
my $init_code = $dataname{$dataname}{init_code};
my $finish_code = $dataname{$dataname}{finish_code};
my $decimals = $dataname{$dataname}{decimals};
my $is_time = $dataname{$dataname}{is_time};
my $mode = $dataname{$dataname}{mode};
my $types = $dataname{$dataname}{types};

my $fmt_std = '%' . ($decimals ? (($decimals + 5) . ".${decimals}f") : "${decimals}d");
my $fmt_whole = '%' . ($decimals ? (($decimals + 9) . ".${decimals}f") : "${decimals}d");
my $fmt_seconds = '%0' . ($decimals ? (($decimals + 3) . ".${decimals}f") : "2d");

my $dbh = DBI->connect("dbi:SQLite:dbname=$cache_db", '', '',
		       { RaiseError => 1, PrintError => 0, AutoCommit => 1 });

my %modes = (
    'data' => {
	create_tables => [
	    'CREATE TABLE IF NOT EXISTS data (
		tar_id INTEGER NOT NULL,
		dataname VARCHAR(256),
		count INTEGER,
		min FLOAT,
		max FLOAT,
		total FLOAT,
		square FLOAT
	    );',
	    'CREATE INDEX IF NOT EXISTS data_id ON data(tar_id, dataname);',
	    'CREATE INDEX IF NOT EXISTS data_name ON data(dataname, tar_id);',
	],
	count_clients => 0,
	delete_data   => 'DELETE FROM data WHERE tar_id = ?;',
	get_data =>
	    'SELECT count, total, square, min, max
	     FROM data
	     WHERE tar_id = ?
	       AND dataname = ?;',
	add_data =>
	    'INSERT INTO data
	     (tar_id, dataname, count, total, square, min, max)
	     VALUES (?, ?, ?, ?, ?, ?, ?);',
    },
    'summary' => {
	create_tables => [
	    'CREATE TABLE IF NOT EXISTS summary (
		tar_id INTEGER NOT NULL,
		dataname VARCHAR(256),
		n_clients INTEGER,
		count INTEGER,
		min FLOAT,
		max FLOAT,
		total FLOAT,
		square FLOAT
	    );',
	    'CREATE INDEX IF NOT EXISTS sumary_id ON summary(tar_id, dataname, n_clients);',
	    'CREATE INDEX IF NOT EXISTS sumary_name ON summary(dataname, n_clients, tar_id);',
	],
	count_clients => 1,
	delete_data   => 'DELETE FROM summary WHERE tar_id = ?;',
	get_data =>
	    'SELECT count, total, square, min, max, n_clients
	     FROM summary
	     WHERE tar_id = ?
	       AND dataname = ?;',
	add_data =>
	    'INSERT INTO summary
	     (tar_id, dataname, count, total, square, min, max, n_clients)
	     VALUES (?, ?, ?, ?, ?, ?, ?, ?);',
    },
);

exists $modes{$mode} or die "Internal error, mode=$mode not defined\n";

run_sql(<<EOF);
CREATE TABLE IF NOT EXISTS tarballs (
    id INTEGER NOT NULL PRIMARY KEY,
    filename VARCHAR(256),
    filesize INTEGER,
    mtime INTEGER,
    topology VARCHAR(256),
    suffix VARCHAR(32),
    testbed VARCHAR(32),
    boot_time INTEGER,
    update_method VARCHAR(256),
    schedule VARCHAR(256),
    file_size INTEGER,
    run_time INTEGER,
    n_servers INTEGER,
    router_levels INTEGER,
    n_clients INTEGER
);
EOF

run_sql(<<EOF);
CREATE INDEX IF NOT EXISTS tarballs_name
ON tarballs(filename);
EOF

my $find_tarball = $dbh->prepare(<<EOF);
SELECT id, filesize, mtime
FROM tarballs
WHERE filename = ?;
EOF

my $delete_tarball = $dbh->prepare(<<EOF);
DELETE FROM tarballs WHERE id = ?;
EOF

my $max_tar_id = $dbh->prepare(<<EOF);
SELECT max(id) FROM tarballs;
EOF

my $add_tarball = $dbh->prepare(<<EOF);
INSERT INTO tarballs
(id, filename, filesize, mtime, topology, suffix, testbed, boot_time, update_method,
 schedule, file_size, run_time, n_servers, router_levels, n_clients)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
EOF

for my $create (@{$modes{$mode}{create_tables}}) {
    run_sql($create);
}

my $get_data = $dbh->prepare($modes{$mode}{get_data});
my $add_data = $dbh->prepare($modes{$mode}{add_data});
my $count_clients = $modes{$mode}{count_clients};

# prepare to delete data for any table whish already exists; if a table
# has not yet been create, obviously no need
my @delete_data;
for my $mm (keys %modes) {
    eval {
	my $dd = $dbh->prepare($modes{$mm}{delete_data});
	push @delete_data, $dd;
    };
    if ($@) {
	$@ =~ /no such table/ or die $@;
    }
}

# type filter for unicast includes logs (to get request/done), for
# multicast it does not need to
my $unicast_filter = $types;
$count_clients && ! exists $unicast_filter->{65534}
    and $unicast_filter = { %$unicast_filter, 65534 => undef };

my $dir;
END { defined $dir and remove_tree($dir); undef $dir; }

my %counts = ();
for my $tb (@ARGV) {
    stat $tb or die "$tb: $!\n";
    my $tfilesize = (stat _)[7];
    my $tmtime = (stat _)[9];
    (my $tfilename = $tb) =~ s!^.*/!!;
    my %tar_info = parse_tarball($tfilename, $tb);
    my $title = sprintf "%-9s %-9s %4d", @tar_info{qw(update schedule file_size)};
    # check if we already have this tarball and it is up to date
    my ($id, $cfilesize, $cmtime) = $dbh->selectrow_array($find_tarball, {}, $tfilename);
    if (! defined $cmtime || $cmtime != $tmtime || $cfilesize != $tfilesize) {
	if (defined $cmtime) {
	    $delete_tarball->execute($tfilename, $id);
	    # we need to delete this tarball from all data tables which exists,
	    # not just for the one we are using now
	    for my $dd (@delete_data) {
		$dd->execute($tfilename, $id);
	    }
	} else {
	    ($id) = 1 + ($dbh->selectrow_array($max_tar_id, {}) || 0);
	}
	$add_tarball->execute($id, $tfilename, $tfilesize, $tmtime,
			      @tar_info{qw(topology suffix testbed boot_time
					update schedule file_size run_time
					n_servers router_levels n_clients)});
    }
    # check if data is already cached
    my @data = @{ $dbh->selectall_arrayref($get_data, {}, $id, $dataname) };
    if (! @data) {
	# not cached, we need to collect it
	$dir = tempdir() or die "tmpdir: $!\n";
	my $ptb = $tb =~ m!^/! ? $tb : "./$tb";
	run_cmd("tar $tb", 'tar', 'xf', $ptb, '-C', $dir);
	defined $sort_num or print "$tfilename\n";
	my @clients;
	if ($count_clients) {
	    # for multicast, the server does now know how many clients
	    # there are, only if there are any or not; so we need client
	    # logs to know when they start/end (this is less precise
	    # than server logs); for unicast we use the server log
	    my ($regex, $request, $done);
	    if ($tar_info{is_multicast}) {
		$regex = qr/^client\d+\./;
		$request = 'start';
		$done = 'end';
	    } else {
		$regex = qr/^server\d+\./;
		$request = 'request';
		$done = 'done';
	    }
	    my %change;
	    opendir(DIR, $dir) or die "$dir: $!\n";
	    while (defined (my $ent = readdir DIR)) {
		$ent =~ $regex or next;
		my $lwmon = Lwmon->new("$dir/$ent");
		my ($start, $end) = (0, 0);
		while (defined (my $packet = $lwmon->nextrecord({ 65534 => undef }))) {
		    for my $item (@{$packet->{data}}) {
			my $type = $item->{type};
			$type == 65534 or next;
			exists $item->{parm} or next;
			my $diff;
			if ($item->{parm} eq $request) {
			    $start && $tar_info{is_multicast}
				and die "$tb ($ent): multiple $request loga\n";
			    $start++;
			    $diff = 1;
			} elsif ($item->{parm} eq $done) {
			    $start > $end
				or die "$tb ($ent): $done log without $request\n";
			    $end++;
			    $diff = -1;
			} else {
			    next;
			}
			my $ts = $packet->{timestamp};
			if (exists $change{$ts}) {
			    $change{$ts} += $diff;
			} else {
			    $change{$ts} = $diff;
			}
		    }
		}
	    }
	    closedir DIR;
	    @clients = map { [$_ => $change{$_}] } sort { $a <=> $b } keys %change;
	}
	my %totals;
	my ($total, $square, $count, $min, $max) = (0, 0, 0);
	my $filter = $tar_info{is_multicast} ? $types : $unicast_filter;
	opendir(DIR, $dir) or die "$dir: $!\n";
	while (defined (my $ent = readdir DIR)) {
	    $ent =~ $file_regex or next;
	    my $lwmon = Lwmon->new("$dir/$ent");
	    my %data;
	    $init_code and $init_code->(\%data);
	    my $lastr;
	    my $n_clients = 0;
	    while (defined (my $packet = $lwmon->nextrecord($filter))) {
		# first process any data logs - they refer to some interval ending
		# at the current message, so we want to process them now before
		# figuring out any change in number of active clients
		for my $item (@{$packet->{data}}) {
		    my $type = $item->{type};
		    exists $types->{$type} or next;
		    my $code = $types->{$type};
		    if (ref($code) eq 'HASH') {
			exists $code->{$item->{name}} or next;
			$code = $code->{$item->{name}};
		    }
		    $code->($tb, $ent, \%data, $packet, $item, $n_clients);
		}
		# and if we are counting clients, apply any changes
		$count_clients or next;
		my $ts = $packet->{timestamp};
		# we allow the change to happen a millisecond later to include
		# the "immediate" round of measures... and we implement that
		# by saying $ts > ... rather than $ts >= ...
		while (@clients && $ts > $clients[0][0]) {
		    $n_clients += $clients[0][1];
		    shift @clients;
		}
	    }
	    for my $tp ($finish_code->($tb, $ent, \%data)) {
		my ($count, $total, $square, $min, $max, $nc) = @$tp;
		if (exists $totals{$nc}) {
		    $totals{$nc}[0] += $count;
		    $totals{$nc}[1] += $total;
		    $totals{$nc}[2] += $square;
		    $totals{$nc}[3] > $min and $totals{$nc}[3] = $min;
		    $totals{$nc}[4] < $max and $totals{$nc}[4] = $max;
		} else {
		    $totals{$nc} = [$count, $total, $square, $min, $max];
		    $count_clients and push @{$totals{$nc}}, $nc;
		}
	    }
	}
	closedir DIR;
	scalar(keys %totals) or die "$tb: no data\n";
	for my $nc (keys %totals) {
	    $add_data->execute($id, $dataname, @{$totals{$nc}});
	    push @data, $totals{$nc};
	}
	remove_tree($dir);
	undef $dir;
    }
    defined $sort_num or next;
    exists $counts{$title} or $counts{$title} = {};
    for my $data (@data) {
	my $n_clients = $data->[5] || 0;
	if (exists $counts{$title}{$n_clients}) {
	    $counts{$title}{$n_clients}[0] += $data->[0];
	    $counts{$title}{$n_clients}[1] += $data->[1];
	    $counts{$title}{$n_clients}[2] += $data->[2];
	    $counts{$title}{$n_clients}[3] > $data->[3]
		and $counts{$title}{$n_clients}[3] = $data->[3];
	    $counts{$title}{$n_clients}[4] < $data->[4]
		and $counts{$title}{$n_clients}[4] = $data->[4];
	} else {
	    $counts{$title}{$n_clients} = $data;
	}
    }
}
defined $sort_num or exit 0;

my $str_std = '%' . length(sprintf $fmt_std, 0) . 's';
my $no_std = sprintf $str_std, '-';
my @results;
for my $title (keys %counts) {
    for my $n_clients (sort { $a <=> $b } keys %{$counts{$title}}) {
	my ($count, $total, $square, $min, $max) = @{$counts{$title}{$n_clients}};
	my $avg = $total / $count;
	my $std;
	if ($count > 1) {
	    my $var = ($square - 2 * $avg * $total + $avg * $avg * $count)
		    / ($count - 1);
	    # avoid square root of "-0"
	    $var < 0 && $var > -1e-10 and $var = 0;
	    $std = sqrt($var);
	    $std = sprintf $fmt_std, $std;
	} else {
	    $std = $no_std;
	}
	my $tt = $title;
	$count_clients and $tt .= sprintf "%8d", $n_clients;
	push @results, [$tt, $avg, $count, $min, $max, $std];
    }
}

my $str_data = '%' . length(sprintf $fmt_whole, 0) . 's';
printf "UPDATE    SCHEDULE  SIZE%s $str_data #DATA $str_data $str_data $str_std\n",
       ($count_clients ? ' #CLIENT' : ''), qw(AVG MIN MAX STD);
my @sorted;
if ($sort_num) {
    @sorted = sort { $a->[$sort_index] <=> $b->[$sort_index] ||
		     $a->[0] cmp $b->[0] } @results;
} else {
    @sorted = sort { $a->[$sort_index] cmp $b->[$sort_index] ||
		     $a->[0] cmp $b->[0] } @results;
}
for my $result (@sorted) {
    my ($title, $avg, $count, $min, $max, $std) = @$result;
    my $time = fmt_data($avg);
    $count = sprintf "%5d", $count;
    $min = fmt_data($min);
    $max = fmt_data($max);
    print "$title $time $count $min $max $std\n";
}

$dbh->disconnect();

sub fmt_data {
    my ($sec) = @_;
    $raw_data || ! $is_time || $sec < 60 and return sprintf $fmt_whole, $sec;
    my $m = int($sec / 60);
    $sec = sprintf $fmt_seconds, $sec - $m * 60;
    if ($m < 60) {
	return sprintf "%5d:%s", $m, $sec;
    } else {
	return sprintf "%2d:%02d:%s", int($m / 60), $m % 60, $sec;
    }
}

sub run_cmd {
    my ($name, @cmd) = @_;
    system(@cmd) == 0 and return;
    $? == -1 and die "$name: $!\n";
    $? & 0x7f and die "$name: killed by signal " . ($? & 0x7f) . "\n";
    die "$name: exited with status " . ($? >> 8) . "\n";
}

sub run_sql {
    my ($query) = @_;
    $dbh->do($query) || die "$query\n" . $dbh->errstr . "\n";
}

sub init_runtime {
    my ($data) = @_;
    $data->{time} = 0;
    $data->{place} = 0;
    $data->{any} = 0;
}

sub get_runtime {
    my ($tb, $ent, $data, $packet, $item, $n_clients) = @_;
    exists $item->{name} or return;
    $item->{name} =~ /^client_/ or return;
    exists $item->{parm} or return;
    my $time = $packet->{timestamp};
    if ($item->{parm} eq 'start') {
	$data->{place} and die "$tb ($ent): misplaced start\n";
	$data->{place} = 1;
	$data->{time} -= $time;
    } elsif ($item->{parm} eq 'end') {
	$data->{place} or die "$tb ($ent): misplaced end\n";
	$data->{place} = 0;
	$data->{time} += $time;
	$data->{any} = 1;
    }
}

sub finish_runtime {
    my ($tb, $ent, $data) = @_;
    $data->{place} and die "$tb ($ent): missing end\n";
    $data->{any} or die "$tb ($ent): no start/end logs\n";
    my $time = $data->{time};
    return ([1, $time, $time * $time, $time, $time, 0]);
}

sub get_value {
    my ($idx, $interval, $scale, $tb, $ent, $data, $packet, $item, $n_clients) = @_;
    my $v = $item->{values}[$idx];
    defined $v or return;
    # scale value as required and also divide by the elapsed time since last measure
    # so we get a normalised "per second" result
    if (defined $interval) {
	my $i = $item->{values}[$interval];
	$i < 1 and return;
	$v /= $i;
    }
    $v *= $scale;
    my $s = $v * $v;
    if (exists $data->{$n_clients}) {
	$data->{$n_clients}[0]++;
	$data->{$n_clients}[1] += $v;
	$data->{$n_clients}[2] += $s;
	$data->{$n_clients}[3] > $v and $data->{$n_clients}[3] = $v;
	$data->{$n_clients}[4] < $v and $data->{$n_clients}[4] = $v;
    } else {
	$data->{$n_clients} = [1, $v, $s, $v, $v, $n_clients];
    }
}

sub finish_values {
    my ($tb, $ent, $data) = @_;
    my @r = map { $data->{$_} } keys %$data;
    @r;
}

