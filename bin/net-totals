#!/usr/bin/perl -w

# XXX this may need changing for the new file name schemes

use strict;
use DBI;
use POSIX 'strftime';

@ARGV == 2 || @ARGV == 3 or die "Usage: $0 MAIN_DATABASE SUMMARY_DAABASE [FILE_PATTERN]\n";
my ($mdb, $sdb, $out) = @ARGV;
my $mh = DBI->connect("dbi:SQLite:dbname=$mdb", '', '',
		      { RaiseError => 1, ReadOnly => 1 });
my $sh = DBI->connect("dbi:SQLite:dbname=$sdb", '', '',
		      { RaiseError => 1, ReadOnly => 0 });

# including MIME::Base64 or similar to just have a shorter instance string...
# or add 8 lines in total?
my $b36 = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';

# we'll need new tables to store these results
$sh->do(<<EOF);
CREATE TABLE IF NOT EXISTS net_summary (
    topology VARCHAR(255),
    instance VARCHAR(255),
    experiment VARCHAR(255),
    schedule VARCHAR(255),
    datasize INT,
    end_run INT,
    host VARCHAR(255),
    n_clients INT,
    interface VARCHAR(255),
    mbytes_received FLOAT,
    mbytes_sent FLOAT
);
EOF
$sh->do(<<EOF);
CREATE INDEX IF NOT EXISTS net_summary_idx
ON net_summary (topology, instance, experiment, schedule, datasize, end_run, host);
EOF

$sh->do(<<EOF);
CREATE TABLE IF NOT EXISTS time_summary (
    topology VARCHAR(255),
    instance VARCHAR(255),
    experiment VARCHAR(255),
    schedule VARCHAR(255),
    datasize INT,
    end_run INT,
    host VARCHAR(255),
    n_clients INT,
    update_time FLOAT,
    user_cpu FLOAT,
    system_cpu FLOAT
);
EOF
$sh->do(<<EOF);
CREATE INDEX IF NOT EXISTS time_summary_idx
ON time_summary (topology, instance, experiment, schedule, datasize, end_run, host);
EOF

# number of clients which actually managed to start... that'll be the
# ones returning status 0 or ending with SIGTERM
my $nclients_handle = $mh->prepare(<<EOF);
SELECT COUNT(*)
FROM run_data
LEFT JOIN lwmon_data
ON run_data.run_id = lwmon_data.run_id
WHERE topology = ?
  AND boot_time = ?
  AND experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND end_run = ?
  AND host like 'client%'
  AND name = 'experiment'
  AND key = 'status'
  AND (value = 0 OR value = 15);
EOF

# list of network interfaces for a host
my $ifaces_handle = $mh->prepare(<<EOF);
SELECT name
FROM run_data
LEFT JOIN lwmon_data
ON run_data.run_id = lwmon_data.run_id
WHERE topology = ?
  AND boot_time = ?
  AND experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND end_run = ?
  AND host = ?
  AND name LIKE 'if%'
GROUP BY name;
EOF

# total network usage for a host and interface
my $usage_handle = $mh->prepare(<<EOF);
SELECT SUM(value)
FROM run_data
LEFT JOIN lwmon_data
ON run_data.run_id = lwmon_data.run_id
WHERE topology = ?
  AND boot_time = ?
  AND experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND end_run = ?
  AND host = ?
  AND name = ?
  AND key = ?;
EOF

# update time for a (client) host
my $utime_handle = $mh->prepare(<<EOF);
SELECT key, value
FROM run_data
LEFT JOIN lwmon_data
ON run_data.run_id = lwmon_data.run_id
WHERE topology = ?
  AND boot_time = ?
  AND experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND end_run = ?
  AND host = ?
  AND name = 'experiment'
  AND key in ('wallclock', 'user', 'system');
EOF

my $net_exists_handle = $sh->prepare(<<EOF);
SELECT COUNT(*)
FROM net_summary
WHERE experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND topology = ?
  AND instance = ?
  AND end_run = ?
  AND host = ?
EOF

# insert data into net summary
my $net_insert_handle = $sh->prepare(<<EOF);
INSERT INTO net_summary
(experiment, schedule, datasize, topology, instance, end_run, host,
 n_clients, interface, mbytes_received, mbytes_sent)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);
EOF

my $net_data_handle = $sh->prepare(<<EOF);
SELECT host, n_clients, interface, mbytes_received, mbytes_sent
FROM net_summary
WHERE experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND topology = ?
  AND instance = ?
  AND end_run = ?;
EOF

my $time_data_handle = $sh->prepare(<<EOF);
SELECT host, n_clients, update_time
FROM time_summary
WHERE experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND topology = ?
  AND instance = ?
  AND end_run = ?;
EOF

my $time_exists_handle = $sh->prepare(<<EOF);
SELECT COUNT(*)
FROM time_summary
WHERE experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND topology = ?
  AND instance = ?
  AND end_run = ?
  AND host = ?
EOF

# insert data into time summary
my $time_insert_handle = $sh->prepare(<<EOF);
INSERT INTO time_summary
(experiment, schedule, datasize, topology, instance, end_run, host, n_clients,
 update_time, user_cpu, system_cpu)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);
EOF

# see if we have already running totals in main summary table
my $exists_handle = $sh->prepare(<<EOF);
SELECT minval, maxval FROM lwmon_summary
WHERE experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND topology = ?
  AND instance = ?
  AND host_type = ?
  AND n_clients = ?
  AND key = ?;
EOF

# insert new running total into main summary table
my $insert_handle = $sh->prepare(<<EOF);
INSERT INTO lwmon_summary
(total, minval, maxval, square, experiment, schedule, datasize,
 topology, instance, host_type, n_clients, key, count)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 1);
EOF

# update existing running total in main summary table
my $update_totals_handle = $sh->prepare(<<EOF);
UPDATE lwmon_summary
SET count = count + 1, total = total + ?, square = square + ?
WHERE experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND topology = ?
  AND instance = ?
  AND host_type = ?
  AND n_clients = ?
  AND key = ?;
EOF
my $update_min_handle = $sh->prepare(<<EOF);
UPDATE lwmon_summary
SET minval = ?
WHERE experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND topology = ?
  AND instance = ?
  AND host_type = ?
  AND n_clients = ?
  AND key = ?;
EOF
my $update_max_handle = $sh->prepare(<<EOF);
UPDATE lwmon_summary
SET maxval = ?
WHERE experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND topology = ?
  AND instance = ?
  AND host_type = ?
  AND n_clients = ?
  AND key = ?;
EOF

my $hosts_handle = $mh->prepare(<<EOF);
SELECT host
FROM run_data
WHERE topology = ?
  AND boot_time = ?
  AND experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND end_run = ?;
EOF

# find all runs for any host
my @runs = @{ $mh->selectall_arrayref(<<EOF) };
SELECT topology, boot_time, experiment, schedule, datasize, end_run
FROM run_data
GROUP BY topology, boot_time, experiment, schedule, datasize, end_run
EOF

my $totruns = @runs;
for (my $nr = 0; $nr < $totruns; $nr++) {
    my $run = $runs[$nr];
    my ($topology, $boot_time, $experiment, $schedule, $datasize, $end_run) = @$run;
    my $dtop = $topology;
    my $instance = b36($boot_time, 7);
    $dtop =~ s/(\D+)$// and $instance .= $1;
    my @sdata = ($experiment, $schedule, $datasize, $dtop, $instance);
    for my $host (map { $_->[0] } @{ $mh->selectall_arrayref($hosts_handle, {}, @$run) }) {
	my ($net_found) =
	    $sh->selectrow_array($net_exists_handle, {}, @sdata, $end_run, $host);
	my $time_found;
	(my $host_type = $host) =~ s/\d+$//;
	$host_type eq 'client'
	    and ($time_found) =
		$sh->selectrow_array($time_exists_handle, {}, @sdata, $end_run, $host);
	$net_found && $time_found and next;
	my ($n_clients) = $mh->selectrow_array($nclients_handle, {}, @$run);
	my @udata = (@sdata, $host_type, $n_clients);
	my $rno = $nr + 1;
	if (! $net_found) {
	    print "NET  @$run $host $rno/$totruns\n";
	    my @ifaces = map { $_->[0] }
			 @{ $mh->selectall_arrayref($ifaces_handle, {}, @$run, $host) };
	    for my $iface (@ifaces) {
		my $inum = '';
		$iface =~ /^if(\d+)$/ && $1 > 1 and $inum = $1;
		my @data;
		for my $key (qw(received sent)) {
		    my ($value) = $mh->selectrow_array($usage_handle, {},
						       @$run, $host, $iface, "bytes_$key");
		    $value *= 1e-6;
		    push @data, $value;
		    my $square = $value * $value;
		    my $skey = ($key eq 'sent' ? 'tot_tx' : 'tot_rx') . $inum;
		    my ($min, $max) =
			$sh->selectrow_array($exists_handle, {}, @udata, $skey);
		    if (defined $min) {
			$update_totals_handle->execute($value, $square, @udata, $skey);
			$value < $min
			    and $update_min_handle->execute($value, @udata, $skey);
			$value > $max
			    and $update_max_handle->execute($value, @udata, $skey);
		    } else {
			$insert_handle->execute($value, $value, $value, $square,
						@udata, $skey);
		    }
		}
		$net_insert_handle->execute(@sdata, $end_run, $host,
					    $n_clients, $iface, @data);
	    }
	}
	if (! $time_found) {
	    print "TIME @$run $host $rno/$totruns\n";
	    my %data = map { ($_->[0] => $_->[1]) }
		       @{ $mh->selectall_arrayref($utime_handle, {}, @$run, $host); };
	    my $wall = 1e-3 * ($data{wallclock} || 0);
	    my $user = 1e-3 * ($data{user} || 0);
	    my $system = 1e-3 * ($data{system} || 0);
	    $time_insert_handle->execute(@sdata, $end_run, $host, $n_clients,
					 $wall, $user, $system);
	    for my $dp (
		['update_time', $wall],
		['total_usercpu', $user],
		['total_syscpu', $system],
		['total_cpu', $user + $system],
	    ) {
		my ($key, $value) = @$dp;
		my $square = $value * $value;
		my ($min, $max) = $sh->selectrow_array($exists_handle, {}, @udata, $key);
		if (defined $min) {
		    $update_totals_handle->execute($value, $square, @udata, $key);
		    $value < $min and $update_min_handle->execute($value, @udata, $key);
		    $value > $max and $update_max_handle->execute($value, @udata, $key);
		} else {
		    $insert_handle->execute($value, $value, $value, $square, @udata, $key);
		}
	    }
	}
    }
    if (defined $out) {
	my $n_clients;
	my %hosts;
	my %stat;
	for my $np (@{ $sh->selectall_arrayref($net_data_handle, {}, @sdata, $end_run) }) {
	    my ($host, $nc, $interface, $mbytes_received, $mbytes_sent) = @$np;
	    (my $host_type = $host) =~ s/(\d+)$//;
	    my $host_number = $1;
	    if (defined $n_clients) {
		$n_clients == $nc
		    or die "Internal error, inconsistent n_clients (@sdata $end_run)\n";
	    } else {
		$n_clients = $nc;
	    }
	    my $inum = '';
	    $interface =~ /(\d+)$/ && $1 > 1 and $inum = $1;
	    $hosts{$host_type}{$host_number}{"tx$inum"} = $mbytes_sent;
	    $hosts{$host_type}{$host_number}{"rx$inum"} = $mbytes_received;
	    exists $stat{"net$inum"}{$host_type}
		or $stat{"net$inum"}{$host_type} =
		    [0, 0, 0, $mbytes_sent, $mbytes_sent,
			0, 0, $mbytes_received, $mbytes_received];
	    $stat{"net$inum"}{$host_type}[0]++;
	    $stat{"net$inum"}{$host_type}[1] += $mbytes_sent;
	    $stat{"net$inum"}{$host_type}[2] += $mbytes_sent * $mbytes_sent;
	    $stat{"net$inum"}{$host_type}[3] > $mbytes_sent
		and $stat{"net$inum"}{$host_type}[3] = $mbytes_sent;
	    $stat{"net$inum"}{$host_type}[4] < $mbytes_sent
		and $stat{"net$inum"}{$host_type}[4] = $mbytes_sent;
	    $stat{"net$inum"}{$host_type}[5] += $mbytes_received;
	    $stat{"net$inum"}{$host_type}[6] += $mbytes_received * $mbytes_received;
	    $stat{"net$inum"}{$host_type}[7] > $mbytes_received
		and $stat{"net$inum"}{$host_type}[7] = $mbytes_received;
	    $stat{"net$inum"}{$host_type}[8] < $mbytes_received
		and $stat{"net$inum"}{$host_type}[8] = $mbytes_received;
	}
	for my $tp (@{ $sh->selectall_arrayref($time_data_handle, {}, @sdata, $end_run) }) {
	    my ($host, $nc, $update_time) = @$tp;
	    (my $host_type = $host) =~ s/(\d+)$//;
	    my $host_number = $1;
	    if (defined $n_clients) {
		$n_clients == $nc
		    or die "Internal error, inconsistent n_clients (@sdata $end_run)\n";
	    } else {
		$n_clients = $nc;
	    }
	    $hosts{$host_type}{$host_number}{update_time} = $update_time;
	    exists $stat{time}{$host_type}
		or $stat{time}{$host_type} = [0, 0, 0, $update_time, $update_time];
	    $stat{time}{$host_type}[0]++;
	    $stat{time}{$host_type}[1] += $update_time;
	    $stat{time}{$host_type}[2] += $update_time * $update_time;
	    $stat{time}{$host_type}[3] > $update_time
		and $stat{time}{$host_type}[3] = $update_time;
	    $stat{time}{$host_type}[4] < $update_time
		and $stat{time}{$host_type}[4] = $update_time;
	}
	my $ofile = sprintf $out, join('.', @sdata, $end_run);
	open(OF, '>', $ofile) or die "$ofile: $!\n";
	print OF "@sdata $end_run:\n" or die "$ofile: $!\n";
	print OF "n_clients: $n_clients\n" or die "$ofile: $!\n";
	print OF "\n" or die "$ofile: $!\n";
	for my $ht (sort keys %hosts) {
	    my $title = sprintf "%-24s   %8s  %8s  %8s  %5s   %7s\n",
				$ht, 'AVG', 'MIN', 'MAX', 'COUNT', 'STD';
	    if ($stat{net}{$ht}[0] > 1) {
		print OF $title or die "$ofile: $!\n";
		$title = '';
		avg($ofile, 'Total MB sent:', $stat{net}{$ht}, 1);
		avg($ofile, 'Total MB received:', $stat{net}{$ht}, 5);
	    }
	    if (exists $stat{net2}{$ht} && $stat{net2}{$ht}[0] > 1) {
		print OF $title or die "$ofile: $!\n";
		$title = '';
		avg($ofile, 'Total MB sent (if2):', $stat{net2}{$ht}, 1);
		avg($ofile, 'Total MB recd (if2):', $stat{net2}{$ht}, 5);
	    }
	    if (exists $stat{time}{$ht} && $stat{time}{$ht}[0] > 1) {
		print OF $title or die "$ofile: $!\n";
		$title = '';
		avg($ofile, 'Update time:', $stat{time}{$ht}, 1);
	    }
	    my $indent;
	    if ($title eq '') {
		print OF "\n" or die "$ofile: $!\n";
		$indent = '    ';
	    } else {
		$indent = '';
	    }
	    for my $hn (sort { $a <=> $b } keys %{$hosts{$ht}}) {
		my $H = $hosts{$ht}{$hn};
		print OF "$indent$ht$hn\n" or die "$ofile: $!\n";
		for my $k (sort keys %$H) {
		    printf OF "%s    %-12s %9.3f\n", $indent, "$k:", $H->{$k}
			or die "$ofile: $!\n";
		}
	    }
	    print OF "\n" or die "$ofile: $!\n";
	}
	close OF or die "$ofile: $!\n";
    }
}

sub avg {
    my ($ofile, $title, $arr, $idx) = @_;
    my $count = $arr->[0];
    my $total = $arr->[$idx];
    my $square = $arr->[$idx + 1];
    my $min = $arr->[$idx + 2];
    my $max = $arr->[$idx + 3];
    my $avg = $total / $count;
    if ($count > 1) {
	my $var = ($square - 2 * $avg * $total + $avg * $avg * $count)
		/ ($count - 1);
	# avoid square root of "-0"
	$var < 0 && $var > -1e-10 and $var = 0;
	my $std = sqrt($var);
	printf OF "    %-20s   %8.3f  %8.3f  %8.3f  %5d   %7.1f\n",
		  $title, $avg, $min, $max, $count, $std
	    or die "$ofile: $!\n";
    } else {
	printf OF "    %-20s   %8.3f  %8.3f  %8.3f  %5d         -\n",
		  $title, $avg, $min, $max, $count
	    or die "$ofile: $!\n";
    }
}

sub b36 {
    my ($v, $l) = @_;
    my $r = '';
    while ($l-- > 0 || $v > 0) {
	$r = substr($b36, $v % 36, 1) . $r;
	$v = int($v / 36);
    }
    $r;
}

