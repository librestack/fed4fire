#!/usr/bin/perl -w

use strict;
use DBI;
use POSIX 'strftime';

@ARGV >= 1 or die "Usage: $0 DATABASE [COMMAND]...\n";
my $database = shift @ARGV;
my $dbh = DBI->connect("dbi:SQLite:dbname=$database", '', '',
		       { RaiseError => 1, ReadOnly => 1 });

my %what = (
    #            name          key                          scale  format  unit
    load     => ['lavg',       '1minute',                   0.01,  '%.2f', '' ],

    tx       => ['if1',        'bytes_sent',                1e-6,  '%.1f', 'MB/s' ],
    rx       => ['if1',        'bytes_received',            1e-6,  '%.1f', 'MB/s' ],
    net      => ['if1',        'bytes_sent+bytes_received', 1e-6,  '%.1f', 'MB/s' ],
    tx2      => ['if2',        'bytes_sent',                1e-6,  '%.1f', 'MB/s' ],
    rx2      => ['if2',        'bytes_received',            1e-6,  '%.1f', 'MB/s' ],
    net2     => ['if2',        'bytes_sent+bytes_received', 1e-6,  '%.1f', 'MB/s' ],

    mem      => ['memswap',    'used_memory_pages',         1/256, '%.0f', 'MB' ],
    swap     => ['memswap',    'used_swap_pages',           1/256, '%.0f', 'MB' ],

    usercpu  => ['cpu',        'user',                      1e-3,  '%.3f', '' ],
    syscpu   => ['cpu',        'system',                    1e-3,  '%.3f', '' ],
    totcpu   => ['cpu',        'user+system',               1e-3,  '%.3f', '' ],

#   duration => ['experiment', 'wallclock',                 1e-3,  '%.3f', 'sec' ],
);

my @where = ("host = 'server0'"); # see comment below
my (@what, $count, $output, $tfile, $exclude_checksum);
while (@ARGV) {
    my $cmd = shift @ARGV;
    if ($cmd =~ /^run=(\d+)$/i) {
	push @where, "end_run LIKE '$1%'";
	next;
    }
    if ($cmd =~ /^top(?:ology)?=(\S+)$/i) {
	push @where, "topology = '$1'";
	next;
    }
    if ($cmd =~ /^boot(?:_time)?(=|>|<)(\S+)$/i) {
	push @where, "boot_time $1 $2";
	next;
    }
    if ($cmd =~ /^exp(?:eriment)?=(\S+)$/i) {
	push @where, "experiment = '$1'";
	next;
    }
    if ($cmd =~ /^sched(?:ule)?=(\S+)$/i) {
	push @where, "schedule = '$1'";
	next;
    }
    if ($cmd =~ /^(?:data)?size(=|<|>|<=|>=)(\d+)$/i) {
	push @where, "datasize $1 $2";
	next;
    }
    if ($cmd =~ /^(client|server|router):(\w+)$/i) {
	my ($type, $key) = (lc($1), lc($2));
	exists $what{$key} or die "Invalid key: $2\n";
	push @what, [$type, $key];
	next;
    }
    if ($cmd eq 'all') {
	for my $type (qw(client router server)) {
	    for my $key (keys %what) {
		push @what, [$type, $key];
	    }
	}
	next;
    }
    if ($cmd eq 'count') {
	$count = 1;
	next;
    }
    if ($cmd =~ /^out(?:put)?=(.*)$/i) {
	$output = $1;
	next;
    }
    if ($cmd =~ /^txt(?:out)?=(.*)$/i) {
	$tfile = $1;
	next;
    }
    if ($cmd eq 'exclude_checksum') {
	$exclude_checksum = 1;
	next;
    }
    die "Unknown command: $cmd\n";
}
$count || @what or die "No data requested\n";

# find all runs: we know a network must have a server0, as there is always
# at least 1 server; all other hosts will share the same information for
# the same run
my $where = join("\n  AND ", @where);
my @runs = @{ $dbh->selectall_arrayref(<<EOF) };
SELECT topology, boot_time, experiment, schedule, datasize, end_run
FROM run_data
WHERE $where
GROUP BY topology, boot_time, experiment, schedule, datasize, end_run;
EOF

my $host_handle = $dbh->prepare(<<EOF);
SELECT host
FROM run_data
WHERE topology = ?
  AND boot_time = ?
  AND experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND end_run = ?
GROUP BY host;
EOF

my $tx_handle = $dbh->prepare(<<EOF);
SELECT timestamp, value
FROM run_data, lwmon_data
WHERE run_data.run_id = lwmon_data.run_id
  AND topology = ?
  AND boot_time = ?
  AND experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND end_run = ?
  AND host = 'server0'
  AND name = 'if1'
  AND key = 'bytes_sent'
ORDER BY timestamp
LIMIT 30;
EOF

my $rx_handle = $dbh->prepare(<<EOF);
SELECT MIN(timestamp), MAX(timestamp)
FROM run_data, lwmon_data
WHERE run_data.run_id = lwmon_data.run_id
  AND topology = ?
  AND boot_time = ?
  AND experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND end_run = ?
  AND host = ?
  AND name = 'if1'
  AND key = 'bytes_received'
  AND value > 500
EOF

my $end_handle = $dbh->prepare(<<EOF);
SELECT timestamp, value
FROM run_data, lwmon_data
WHERE run_data.run_id = lwmon_data.run_id
  AND topology = ?
  AND boot_time = ?
  AND experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND end_run = ?
  AND host = ?
  AND name = 'experiment'
  AND key = 'wallclock';
EOF

my $data_handle = $dbh->prepare(<<EOF);
SELECT timestamp, value
FROM run_data, lwmon_data
WHERE run_data.run_id = lwmon_data.run_id
  AND topology = ?
  AND boot_time = ?
  AND experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND end_run = ?
  AND host = ?
  AND name = ?
  AND key = ?
  ORDER BY timestamp;
EOF

my ($odbh, $exists_handle, $insert_handle, $update_handle);
if (defined $output && @what) {
    $odbh = DBI->connect("dbi:SQLite:dbname=$output", '', '',
			 { RaiseError => 1, AutoCommit => 0 });
    run_update(<<EOF, 1);
CREATE TABLE IF NOT EXISTS lwmon_summary (
    experiment VARCHAR(255),
    schedule VARCHAR(255),
    datasize INT,
    host_type VARCHAR(255),
    topology VARCHAR(255),
    n_clients INT,
    key VARCHAR(255),
    count INT,
    total FLOAT,
    square FLOAT
);
EOF
    run_update(<<EOF, 1);
CREATE INDEX IF NOT EXISTS lwmon_summary_type
ON lwmon_summary(experiment, schedule, datasize, host_type, topology, n_clients, key);
EOF
    $exists_handle = $odbh->prepare(<<EOF);
SELECT COUNT(*) FROM lwmon_summary
WHERE experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND topology = ?
  AND host_type = ?
  AND n_clients = ?
  AND key = ?;
EOF
    $insert_handle = $odbh->prepare(<<EOF);
INSERT INTO lwmon_summary
(total, square, experiment, schedule, datasize, topology, host_type, n_clients, key, count)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 1);
EOF
    $update_handle = $odbh->prepare(<<EOF);
UPDATE lwmon_summary
SET count = count + 1, total = total + ?, square = square + ?
WHERE experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND topology = ?
  AND host_type = ?
  AND n_clients = ?
  AND key = ?;
EOF
}

my $sep = ' ';
#my $sep = '|';
my %count;
my $do_print = ! $odbh;
for my $run (sort { $a->[5] <=> $b->[5] ||
		    $a->[2] cmp $b->[2] ||
		    $a->[3] cmp $b->[3] ||
		    $a->[4] <=> $b->[4] ||
		    $a->[0] cmp $b->[0] ||
		    $a->[1] <=> $b->[1] 
		  } @runs)
{
    my ($topology, $boot_time, $experiment, $schedule, $datasize, $run_ts) = @$run;
    if (defined $tfile && $do_print) {
	my $dest = sprintf $tfile, "$experiment.$schedule.$datasize.$topology.$run_ts";
	open(TFILE, '>', $dest) or die "$dest: $!\n";
	select TFILE;
    }
    my $dtop = $topology;
    $dtop =~ s/\D+$//;
    if (@what) {
	printf "RUN: %-10s %-20s %-10s %-10s %5d  %s\n",
	       $topology, ($boot_time ? fmt_ts($boot_time) : ''),
	       $experiment, $schedule, $datasize, fmt_time($run_ts);
	# figure out the likely time required to run the file hash; this
	# will be the timestamp the server shows some network activity,
	# minus the first timestamp produced by the server
	my @tx = @{ $dbh->selectall_arrayref($tx_handle, {}, @$run) };
	my $timebase = $tx[0][0];
	my ($start_time, $end_offset);
	if ($exclude_checksum) {
	    ($start_time) = map { $_->[0] } grep { $_->[1] } @tx;
	    $end_offset = $start_time - $timebase;
	} else {
	    $start_time = $timebase;
	    $end_offset = 0;
	}
	my @uhosts = map { $_->[0] }
		    @{ $dbh->selectall_arrayref($host_handle, {}, @$run) };
	# determine when each client started and completed
	my (%nc, @hosts, %uhosts);
	for my $host (@uhosts) {
	    if ($host =~ /^client(\d+)$/) {
		$uhosts{$1} = 1;
		my ($start, $end);
		if (0) {
		    my $wall_time;
		    ($end, $wall_time) =
			$dbh->selectrow_array($end_handle, {}, @$run, $host);
		    defined $wall_time or next; # not supposed to happen
		    # because all measurements are "the last second", we count
		    # clients as having started and ended 1 second later than
		    # the timestamps suggest
		    $end++;
		    $start = $end + 1 - int($wall_time / 1000 + .9);
		    $end -= $end_offset;
		} else {
		    ($start, $end) = $dbh->selectrow_array($rx_handle, {}, @$run, $host);
		}
		while ($start <= $end) {
		    exists $nc{$start} ? ($nc{$start}++) : ($nc{$start} = 1);
		    $start++;
		}
	    } else {
		push @hosts, $host;
	    }
	}
	unshift @hosts, map { "client$_" }  sort { $a <=> $b } keys %uhosts;
	# now extract the data required
	my $fmt = "%4d $sep %7d";
	my $title1 = " run $sep   num  ";
	my $title2 = "time $sep clients";
	my $title3 = "     $sep        ";
	my %data;
	my $column = 0;
	my (@host_type, @key);
	for my $what (@what) {
	    my ($type, $key) = @$what;
	    my ($name, $item, $scale, $format, $unit) = @{$what{$key}};
	    my $tl = length $type;
	    my @h = grep { substr($_, 0, $tl) eq $type } @hosts;
	    my $h = join(' ', @h);
	    my $tk = "$type\:$key";
	    my $clen = length($tk);
	    $clen < length($h) and $clen = length($h);
	    $clen < length($unit) and $clen = length($unit);
	    $title1 .= " $sep " . adjust($tk, $clen);
	    my ($l1, $l2);
	    $title2 .= " $sep " . adjust($h, $clen, \$l1, \$l2);
	    $title3 .= " $sep " . adjust($unit, $clen);
	    $fmt .= " $sep$l1";
	    for my $h (@h) {
		$fmt .= ' %' . (length $h) . 's';
		# get data for this host
		my %D;
		for my $kw (split(/\+/, $item)) {
		    for my $data (@{ $dbh->selectall_arrayref($data_handle, {},
				     @$run, $h, $name, $kw) })
		    {
			my ($timestamp, $value) = @$data;
			defined $D{$timestamp} or $D{$timestamp} = 0;
			$D{$timestamp} += $value;
		    }
		}
		for my $timestamp (keys %D) {
		    $data{$timestamp}[$column] = sprintf $format, $D{$timestamp} * $scale;
		}
		if ($odbh) {
		    $host_type[$column] = $type;
		    $key[$column] = $key;
		}
		$column++;
	    }
	    $fmt .= $l2;
	}
	$fmt .= "\n";
	$do_print and print "$title1\n$title2\n$title3\n";
	my $nc = 0;
	my $prev = 0;
	my $clients_seen = 0;
	my $countdown = 10;
	for my $timestamp (sort { $a <=> $b } keys %data) {
	    $timestamp < $start_time and next;
	    my $old_nc = $nc;
	    $nc = $nc{$timestamp} || 0;
	    # some early experiments keep going even though all clients have
	    # terminated; now they automatically stop, but for old data,
	    # this will stop retrieving results after the end of the experiment
	    $nc == 0 && $clients_seen && $countdown-- < 1 and last;
	    $prev = $timestamp;
	    my @prn = ($timestamp - $start_time, $nc);
	    my $has_values = 0;
	    for (my $i = 0; $i < $column; $i++) {
		my $d = $data{$timestamp}[$i];
		if (! defined $d) {
		    $d = '';
		} else {
		    $has_values = 1;
		    if ($odbh) {
			add_data($experiment, $schedule, $datasize, $dtop,
				 $host_type[$i], $nc, $key[$i], $d);
		    }
		}
		push @prn, $d;
	    }
	    $has_values or next;
	    $do_print and printf $fmt, @prn;
	}
	$do_print and print "\n";
	$odbh and run_update(undef, 1);
    }
    if ($count) {
	defined $count{$dtop}{$experiment}{$schedule}{$datasize}
	    or $count{$dtop}{$experiment}{$schedule}{$datasize} = 0;
	$count{$dtop}{$experiment}{$schedule}{$datasize}++;
    }
    if (defined $tfile) {
	close TFILE;
	select STDOUT;
    }
}

$odbh and $odbh->disconnect();
$dbh->disconnect();

if ($count) {
    for my $topology (sort { $a cmp $b } keys %count) {
	for my $experiment (sort { $a cmp $b } keys %{$count{$topology}}) {
	    for my $schedule (sort { $a cmp $b } keys %{$count{$topology}{$experiment}}) {
		for my $datasize (sort { $a <=> $b } keys %{$count{$topology}{$experiment}{$schedule}}) {
		    printf "%3d: %-10s %-10s %-10s %5d\n",
			   $count{$topology}{$experiment}{$schedule}{$datasize},
			   $topology, $experiment, $schedule, $datasize;
		}
	    }
	}
    }
}

sub adjust {
    my ($s, $clen, $p1, $p2) = @_;
    my ($l1, $l2);
    if (length($s) < $clen) {
	$l2 = $clen - length($s);
	$l1 = int($l2 / 2);
	$l2 -= $l1;
	$l1 = ' ' x $l1;
	$l2 = ' ' x $l2;
    } else {
	$l1 = $l2 = '';
    }
    $p1 and $$p1 = $l1;
    $p2 and $$p2 = $l2;
    return $l1 . $s . $l2;
}

sub fmt_time {
    my ($ts) = @_;
    return substr($ts,  0, 4) . '-'
	 . substr($ts,  4, 2) . '-'
	 . substr($ts,  6, 2) . ' '
	 . substr($ts,  8, 2) . ':'
	 . substr($ts, 10, 2) . ':'
	 . substr($ts, 12, 2);
}

sub fmt_ts {
    my ($ts) = @_;
    return strftime('%Y-%m-%d %H:%M:%S', gmtime($ts));
}

sub run_update {
    my ($query, $commit) = @_;
    defined $query and $odbh->do($query) || die "$query\n" . $dbh->errstr . "\n";
    $commit and $odbh->commit || die "Commit: " . $dbh->errstr . "\n";
}

sub add_data {
    my @data = @_;
    my $value = pop @data;
    my $square = $value * $value;
    my ($count) = $odbh->selectrow_array($exists_handle, {}, @data);
    if ($count) {
	$update_handle->execute($value, $square, @data);
    } else {
	$insert_handle->execute($value, $square, @data);
    }
}

