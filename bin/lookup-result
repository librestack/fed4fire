#!/usr/bin/perl -w

use strict;
use DBI;
use POSIX 'strftime';

@ARGV >= 1 or die "Usage: $0 DATABASE [COMMAND]...\n";
my $database = shift @ARGV;
my $dbh = DBI->connect("dbi:SQLite:dbname=$database", '', '',
		       { RaiseError => 1, ReadOnly => 1 });

my %what = (
    load    => ['lavg',    '1minute',                   0.01,  '%.2f' ],

    tx      => ['if1',     'bytes_sent',                1e-3,  '%.0f' ],
    rx      => ['if1',     'bytes_received',            1e-3,  '%.0f' ],
    net     => ['if1',     'bytes_sent+bytes_received', 1e-3,  '%.0f' ],
    tx2     => ['if2',     'bytes_sent',                1e-3,  '%.0f' ],
    rx2     => ['if2',     'bytes_received',            1e-3,  '%.0f' ],
    net2    => ['if1',     'bytes_sent+bytes_received', 1e-3,  '%.0f' ],

    mem     => ['memswap', 'used_memory_pages',         1/256, '%.0f' ],
    swap    => ['memswap', 'used_swap_pages',           1/256, '%.0f' ],

    usercpu => ['cpu',     'user',                      0.001, '%.3f' ],
    syscpu  => ['cpu',     'system',                    0.001, '%.3f' ],
    totcpu  => ['cpu',     'user+system',               0.001, '%.3f' ],
);

my @where = ("host = 'server0'"); # see comment below
my (@what, $count, $output);
while (@ARGV) {
    my $cmd = shift @ARGV;
    if ($cmd =~ /^run=(\d+)$/i) {
	push @where, "run LIKE '$1%'";
	next;
    }
    if ($cmd =~ /^top(?:ology)?=(\S+)$/i) {
	push @where, "topology = '$1'";
	next;
    }
    if ($cmd =~ /^boot(?:_time)?(=|>|<)(\S+)$/i) {
	push @where, "boot_time $1 $2";
	next;
    }
    if ($cmd =~ /^exp(?:eriment)?=(\S+)$/i) {
	push @where, "experiment = '$1'";
	next;
    }
    if ($cmd =~ /^sched(?:ule)?=(\S+)$/i) {
	push @where, "schedule = '$1'";
	next;
    }
    if ($cmd =~ /^(?:data)?size(=|<|>|<=|>=)(\d+)$/i) {
	push @where, "datasize $1 $2";
	next;
    }
    if ($cmd =~ /^(client|server|router):(\w+)$/i) {
	my ($type, $key) = (lc($1), lc($2));
	exists $what{$key} or die "Invalid key: $2\n";
	push @what, [$type, $key];
	next;
    }
    if ($cmd eq 'all') {
	for my $type (qw(client router server)) {
	    for my $key (keys %what) {
		push @what, [$type, $key];
	    }
	}
	next;
    }
    if ($cmd eq 'count') {
	$count = 1;
	next;
    }
    if ($cmd =~ /^out(?:put)?=(.*)$/i) {
	$output = $1;
	next;
    }
    die "Unknown command: $cmd\n";
}
$count || @what or die "No data requested\n";

# find all runs: we know a network must have a server0, as there is always
# at least 1 server; all other hosts will share the same information for
# the same run
my $where = join("\n  AND ", @where);
my @runs = @{ $dbh->selectall_arrayref(<<EOF) };
SELECT topology, boot_time, experiment, schedule, datasize, run
FROM lwmon_data
WHERE $where
GROUP BY topology, boot_time, experiment, schedule, datasize, run;
EOF

my $host_handle = $dbh->prepare(<<EOF);
SELECT host
FROM lwmon_data
WHERE topology = ?
  AND boot_time = ?
  AND experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND run = ?
GROUP BY host;
EOF

my $end_handle = $dbh->prepare(<<EOF);
SELECT timestamp, value
FROM lwmon_data
WHERE topology = ?
  AND boot_time = ?
  AND experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND run = ?
  AND host = ?
  AND name = 'experiment'
  AND key = 'wallclock';
EOF

my $data_handle = $dbh->prepare(<<EOF);
SELECT timestamp, value
FROM lwmon_data
WHERE topology = ?
  AND boot_time = ?
  AND experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND run = ?
  AND host = ?
  AND name = ?
  AND key = ?
  order by timestamp;
EOF

my ($odbh, $exists_handle, $insert_handle, $update_handle);
if (defined $output && @what) {
    $odbh = DBI->connect("dbi:SQLite:dbname=$output", '', '',
			 { RaiseError => 1, AutoCommit => 0 });
    run_update(<<EOF, 1);
create table lwmon_summary (
    experiment varchar(255),
    schedule varchar(255),
    datasize int,
    host_type varchar(255),
    topology varchar(255),
    n_clients int,
    key varchar(255),
    count int,
    total int
);
EOF
    run_update(<<EOF, 1);
create index lwmon_summary_type
on lwmon_summary(experiment, schedule, datasize, host_type, topology, n_clients, key);
EOF
    $exists_handle = $odbh->prepare(<<EOF);
SELECT COUNT(*) FROM lwmon_summary
WHERE experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND topology = ?
  AND host_type = ?
  AND n_clients = ?
  AND key = ?;
EOF
    $insert_handle = $odbh->prepare(<<EOF);
INSERT INTO lwmon_summary
(total, experiment, schedule, datasize, topology, host_type, n_clients, key, count)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, 1);
EOF
    $update_handle = $odbh->prepare(<<EOF);
UPDATE lwmon_summary
SET count = count + 1, total = total + ?
WHERE experiment = ?
  AND schedule = ?
  AND datasize = ?
  AND topology = ?
  AND host_type = ?
  AND n_clients = ?
  AND key = ?;
EOF
}

my %count;
for my $run (sort { $a->[5] <=> $b->[5] ||
		    $a->[2] cmp $b->[2] ||
		    $a->[3] cmp $b->[3] ||
		    $a->[4] <=> $b->[4] ||
		    $a->[0] cmp $b->[0] ||
		    $a->[1] <=> $b->[1] 
		  } @runs)
{
    my ($topology, $boot_time, $experiment, $schedule, $datasize, $run_ts) = @$run;
    my $dtop = $topology;
    $dtop =~ s/\D+$//;
    if (@what) {
	printf "RUN: %-10s %-20s %-10s %-10s %5d  %s\n",
	       $topology, ($boot_time ? fmt_ts($boot_time) : ''),
	       $experiment, $schedule, $datasize, fmt_time($run_ts);
	my @hosts = map { $_->[0] }
		    @{ $dbh->selectall_arrayref($host_handle, {}, @$run) };
	# determine when each client started and completed
	my (%start, %end);
	for my $host (@hosts) {
	    $host =~ /^client/ or next;
	    my ($end, $wall_time) = $dbh->selectrow_array($end_handle, {}, @$run, $host);
	    defined $wall_time or next;
	    # because all measurements are "the last second", we count clients as having
	    # started and ended 1 second later than the timestamps suggest
	    $end{$host} = $end + 1;
	    $start{$host} = $end + 1 - int($wall_time / 1000 + .9);
	}
	# now extract the data required
	my $fmt = '%4d | %7d';
	my $title1 = ' run |   num  ';
	my $title2 = 'time | clients';
	my %data;
	my $column = 0;
	my (@host_type, @key);
	for my $what (@what) {
	    my ($type, $key) = @$what;
	    my $tl = length $type;
	    my @h = grep { substr($_, 0, $tl) eq $type } @hosts;
	    my $h = join(' ', @h);
	    my $tk = "$type\:$key";
	    my ($sp0, $sp1);
	    if (length($tk) < length($h)) {
		my $l1 = length($h) - length($tk);
		my $l2 = int($l1 / 2);
		$l1 -= $l2;
		$sp0 = $sp1 = '';
		$title1 .= ' | ' . (' ' x $l1) . $tk . (' ' x $l2);
		$title2 .= ' | ' . $h;
	    } elsif (length($h) < length($tk)) {
		my $l1 = length($tk) - length($h);
		my $l2 = int($l1 / 2);
		$l1 -= $l2;
		$sp0 = ' ' x $l1;
		$sp1 = ' ' x $l2;
		$title1 .= ' | ' . $tk;
		$title2 .= ' | ' . $sp0 . $h . $sp1;
	    }
	    $fmt .= ' |';
	    for my $h (@h) {
		$fmt .= $sp0 . ' %' . (length $h) . 's' . $sp1;
		my ($name, $item, $scale, $format) = @{$what{$key}};
		# get data for this host
		my %D;
		for my $kw (split(/\+/, $item)) {
		    for my $data (@{ $dbh->selectall_arrayref($data_handle, {},
				     @$run, $h, $name, $kw) })
		    {
			my ($timestamp, $value) = @$data;
			defined $D{$timestamp} or $D{$timestamp} = 0;
			$D{$timestamp} += $value;
		    }
		}
		for my $timestamp (keys %D) {
		    $data{$timestamp}[$column] = sprintf $format, $D{$timestamp} * $scale;
		}
		if ($odbh) {
		    $host_type[$column] = $type;
		    $key[$column] = $key;
		}
		$column++;
	    }
	}
	$fmt .= "\n";
	$odbh or print "$title1\n$title2\n";
	my $nc = 0;
	my $prev = 0;
	my $timebase = undef;
	for my $timestamp (sort { $a <=> $b } keys %data) {
	    defined $timebase or $timebase = $timestamp;
	    for my $t (values %start) {
		$t > $prev && $t <= $timestamp and $nc++;
	    }
	    for my $t (values %end) {
		$t >= $prev && $t < $timestamp and $nc--;
	    }
	    $prev = $timestamp;
	    my @prn = ($timestamp - $timebase, $nc);
	    my $has_values = 0;
	    for (my $i = 0; $i < $column; $i++) {
		my $d = $data{$timestamp}[$i];
		if (! defined $d) {
		    $d = '';
		} elsif ($odbh) {
		    add_data($experiment, $schedule, $datasize, $dtop,
			     $host_type[$i], $nc, $key[$i], $d);
		}
		push @prn, $d;
		$d ne '' and $has_values = 1;
	    }
	    $has_values or next;
	    $odbh and next;
	    printf $fmt, @prn;
	}
	$odbh or print "\n";
	$odbh and run_update(undef, 1);
    }
    if ($count) {
	defined $count{$dtop}{$experiment}{$schedule}{$datasize}
	    or $count{$dtop}{$experiment}{$schedule}{$datasize} = 0;
	$count{$dtop}{$experiment}{$schedule}{$datasize}++;
    }
}

$odbh and $odbh->disconnect();
$dbh->disconnect();

if ($count) {
    for my $topology (sort { $a cmp $b } keys %count) {
	for my $experiment (sort { $a cmp $b } keys %{$count{$topology}}) {
	    for my $schedule (sort { $a cmp $b } keys %{$count{$topology}{$experiment}}) {
		for my $datasize (sort { $a <=> $b } keys %{$count{$topology}{$experiment}{$schedule}}) {
		    printf "%3d: %-10s %-10s %-10s %5d\n",
			   $count{$topology}{$experiment}{$schedule}{$datasize},
			   $topology, $experiment, $schedule, $datasize;
		}
	    }
	}
    }
}

sub fmt_time {
    my ($ts) = @_;
    return substr($ts,  0, 4) . '-'
	 . substr($ts,  4, 2) . '-'
	 . substr($ts,  6, 2) . ' '
	 . substr($ts,  8, 2) . ':'
	 . substr($ts, 10, 2) . ':'
	 . substr($ts, 12, 2);
}

sub fmt_ts {
    my ($ts) = @_;
    return strftime('%Y-%m-%d %H:%M:%S', gmtime($ts));
}

sub run_update {
    my ($query, $commit) = @_;
    defined $query and $odbh->do($query) || die "$query\n" . $dbh->errstr . "\n";
    $commit and $odbh->commit || die "Commit: " . $dbh->errstr . "\n";
}

sub add_data {
    my @data = @_;
    my $value = pop @data;
    my ($count) = $odbh->selectrow_array($exists_handle, {}, @data);
    if ($count) {
	$update_handle->execute($value, @data);
    } else {
	$insert_handle->execute($value, @data);
    }
}

